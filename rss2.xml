<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>观道观</title>
    <link>https://luckytoadventure.com/</link>
    
    <atom:link href="https://luckytoadventure.com/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>选择有时候比努力更重要</description>
    <pubDate>Thu, 28 Dec 2023 09:39:24 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>深度学习第二篇——线性神经网络</title>
      <link>https://luckytoadventure.com/2023/12/28/softmax%E5%9B%9E%E5%BD%92/</link>
      <guid>https://luckytoadventure.com/2023/12/28/softmax%E5%9B%9E%E5%BD%92/</guid>
      <pubDate>Thu, 28 Dec 2023 09:23:23 GMT</pubDate>
      
      <description>&lt;p&gt;本次讲述softamx回归&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>本次讲述softamx回归</p><span id="more"></span><h1 id="softmax回归"><a href="#softmax回归" class="headerlink" title="softmax回归"></a>softmax回归</h1><p>回归：</p><ul><li>单连续数值输出</li><li>自然区间R</li><li>跟真实值的区别作为损失</li></ul><p>分类</p><ul><li>通常多个输出</li><li>输出i是预测为第i类的置信度</li></ul><p>无校验比例</p><ul><li><p>对每个类别进行一位有效编码</p></li><li><p>最大值为预测</p></li><li><script type="math/tex; mode=display">\hat{y} = \underset{i}{\arg\max} {o_i}</script></li><li><p>需要更置信的识别正确类（大余量）</p><script type="math/tex; mode=display">{o_y-o_i} {\geq}{\Delta}(y,i)</script><p>分类数据的简单方法：独热编码。独热编码是一个向量，它的分量和类别一样多，如一个三维分量，其中(1,0,0)对应猫，(0,1,0)对应鸡，(0,0,1)对应狗。</p><script type="math/tex; mode=display">y{\in}{(1,0,0),(0,1,0),(0,0,1)}</script><p>网络结构：</p><p>我们有4个特征和3个可能的输出类别，我们将需要12个标量来表示权重（带下标的w），3个标量表示偏置,3个未规范化的预测：$o_1$、$o_2$和$o_3$。</p><script type="math/tex; mode=display">{o_1} = {x_1w_{11}}+{x_2w_{12}}+{x_3w_{13}}+{x_4w_{14}}+{b_1}\\{o_2} = {x_1w_{21}}+{x_2w_{22}}+{x_3w_{23}}+{x_4w_{24}}+{b_2}\\{o_3} = {x_1w_{31}}+{x_2w_{32}}+{x_3w_{33}}+{x_4w_{34}}+{b_3}\\</script><p>softmax回归是一个单层神经网络。</p><p>softmax函数能将未规范化的预测变换未非负数并且总和为1，同时让模型保持可导的性质。</p><p>尽管softmax是一个非线性函数，但softmax回归输出仍然由输入特征的仿射变换决定，因此，softmax回归是一个线性模型。</p></li></ul><script type="math/tex; mode=display">{\hat{y}} = softmax(o),其中{\hat{y}_j} = {\frac{exp({o_j})}{\displaystyle\sum_{k}{exp({o_k})}}}</script><p>这里，对于所有的$j$总有$0{\leq}{\hat{y}_j}{\leq}1$。因此，${\hat{y}}$可以视为一个正确的概率分布。softmax运算不会改变未规范化的预测$o$之间的大小次序，只会确定分配给每个类别的概率。因此在预测过程中，我们仍然可以用下式来选择最有可能的类别：</p><script type="math/tex; mode=display">\underset{j}{argmax}{\hat{y}_j} = \underset{j}{argmax}{o_j}</script><p>导包：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line">import torch</span><br><span class="line">import torchvision</span><br><span class="line">from torch.utils import data</span><br><span class="line">from torchvision import transforms</span><br><span class="line">from d2l import torch as d2l</span><br><span class="line"></span><br><span class="line">d2l.use_svg_display()</span><br><span class="line">#The purpose of d2l.use_svg_display() is to set up the notebook environment to use Scalable Vector Graphics (SVG) for displaying images. </span><br><span class="line">#By using SVG for display, you can achieve better image quality and scalability in your Jupyter notebook when working with visualizations provided by the D2L library. </span><br></pre></td></tr></table></figure><p>读取数据集</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#读取数据集</span><br><span class="line">#通过ToTensor实例将图像数据从PIL类型变换成32位浮点数形式。</span><br><span class="line">trans = transforms.ToTensor()</span><br><span class="line">mnist_train = torchvision.datasets.FashionMNIST(root = &quot;../data&quot;,train = True,transform=trans,download=True)</span><br><span class="line">mnist_test = torchvision.datasets.FashionMNIST(root = &quot;../data&quot;,train = False,transform=trans,download=True)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def get_fashion_mnist_labels(labels):#@save</span><br><span class="line">    #返回Fashion-mnist数据集的标签</span><br><span class="line">    text_labels = [&#x27;t-shirt&#x27;,&#x27;trouser&#x27;,&#x27;pullover&#x27;,&#x27;dress&#x27;,&#x27;coat&#x27;,&#x27;sandal&#x27;,&#x27;shirt&#x27;,&#x27;sneaker&#x27;,&#x27;bag&#x27;,&#x27;ankle boot&#x27;]</span><br><span class="line">    return [text_labels[int(i)] for i in labels]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#可视化样本</span><br><span class="line">def show_images(imgs,num_rows,num_cols,titles=None,scale = 1.5):#@save</span><br><span class="line">    figsize = (num_rows*scale,num_cols*scale)</span><br><span class="line">    _,axes = d2l.plt.subplots(num_rows,num_cols,figsize=figsize)</span><br><span class="line">    axes = axes.flatten()#将axes扁平化</span><br><span class="line">    for i,(ax,img) in enumerate(zip(axes,imgs)): #这个循环通过 enumerate 函数迭代处理每个子图 (ax) 和对应的图像 (img)。</span><br><span class="line">        if torch.is_tensor(img):#检查图像是否是 PyTorch 张量</span><br><span class="line">            #图像张量</span><br><span class="line">            ax.imshow(img.numpy())#将 PyTorch 张量转换为 NumPy 数组，并使用 ax.imshow() 在子图上显示图像</span><br><span class="line">        else:</span><br><span class="line">            #PIL图像</span><br><span class="line">            ax.imshow(img)#直接使用 ax.imshow() 在子图上显示 PIL 图像</span><br><span class="line">        ax.axes.get_xaxis().set_visible(False)</span><br><span class="line">        ax.axes.get_yaxis().set_visible(False)#将 x 和 y 轴的刻度设置为不可见，以提供更干净的显示效果。</span><br><span class="line">        if titles:#检查是否提供了标题</span><br><span class="line">            ax.set_title(titles[i])#如果提供了标题，则将每个子图的标题设置为对应的标题。</span><br><span class="line">    return axes #返回包含所有子图 axes 的数组</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x,y = next(iter(data.DataLoader(mnist_train,batch_size=18)))#从 MNIST 训练集中获得了一个包含18个图像（x）及其对应标签（y）的批次数据</span><br><span class="line">show_images(x.reshape(18,28,28),2,9,titles=get_fashion_mnist_labels(y));</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#读取小批量</span><br><span class="line">batch_size = 256</span><br><span class="line">def get_dataloader_workers():#@save</span><br><span class="line">    &quot;使用4个进程读取数据&quot;</span><br><span class="line">    return 4</span><br><span class="line">train_iter = data.DataLoader(mnist_train,batch_size,shuffle=True,num_workers=get_dataloader_workers())</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#训练数据所需要的时间</span><br><span class="line">timer = d2l.Timer()</span><br><span class="line">for x,y in train_iter:</span><br><span class="line">    continue</span><br><span class="line">f&#x27;&#123;timer.stop():.2f&#125; sec&#x27;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#整合以上函数</span><br><span class="line">def load_data_fashion_mnist(batch_size,resize=None):</span><br><span class="line">    trans = [transforms.ToTensor()]</span><br><span class="line">    if resize:</span><br><span class="line">        trans.insert(0,transforms.Resize(resize))</span><br><span class="line">    trans = transforms.Compose(trans)</span><br><span class="line">    mnist_train = torchvision.datasets.FashionMNIST(&quot;../data&quot;,train=True,transform=trans,download=True)</span><br><span class="line">    mnist_test = torchvision.datasets.FashionMNIST(&quot;../data&quot;,train=False,transform=trans,download=True)</span><br><span class="line">    return (data.DataLoader(mnist_train,batch_size,shuffle=True,num_workers=get_dataloader_workers()),</span><br><span class="line">           data.DataLoader(mnist_test,batch_size,shuffle=True,num_workers=get_dataloader_workers()))</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#效果展示</span><br><span class="line">train_iter,test_iter = load_data_fashion_mnist(32,resize=64)</span><br><span class="line">for x,y in train_iter:</span><br><span class="line">    print(x.shape,x.dtype,y.shape,y.dtype)</span><br><span class="line">    break</span><br></pre></td></tr></table></figure><h2 id="softmax回归的从零开始实现"><a href="#softmax回归的从零开始实现" class="headerlink" title="softmax回归的从零开始实现"></a>softmax回归的从零开始实现</h2><h3 id="初始化模型参数"><a href="#初始化模型参数" class="headerlink" title="初始化模型参数"></a>初始化模型参数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#softmax回归从零开始实现</span><br><span class="line">import torch</span><br><span class="line">from IPython import display</span><br><span class="line">from d2l import torch as d2l</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">batch_size = 256 #设置数据迭代器的批量大小</span><br><span class="line">train_iter,test_iter = d2l.load_data_fashion_mnist(batch_size)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#初始化参数模型</span><br><span class="line">#这里的每个样本都将用固定长度的向量表示，原始数据集中的每个样本都是28*28像素的图像。</span><br><span class="line">#本次将展平每张图像，把它们看作长度为784的向量。</span><br><span class="line">#我们暂时只把每个像素位置看作一个特征</span><br><span class="line">#我们的数据有10个类别，所以网络输出维度为10。</span><br><span class="line">#因此，权重将构成一个784*10的矩阵，偏置将构成一个1*10的行向量。</span><br><span class="line">#我们将使用正太分布初始化权重w,偏置初始化为0</span><br><span class="line">num_inputs = 784</span><br><span class="line">num_outputs = 10</span><br><span class="line">W = torch.normal(0,0.01,size=(num_inputs,num_outputs),requires_grad=True)</span><br><span class="line">#torch.normal(0, 0.01, size=(num_inputs, num_outputs))：</span><br><span class="line">#这创建了一个大小为 (num_inputs, num_outputs) 的张量，其中每个元素都是从均值为 0、标准差为 0.01 的正态分布中随机抽取的</span><br><span class="line">#requires_grad=True：这指定对涉及此张量的操作进行跟踪，以便进行自动微分，这在神经网络的反向传播过程中是必要的</span><br><span class="line">#在神经网络的上下文中，W 通常用作连接输入层与输出层的权重矩阵。随机初始化有助于打破对称性，并允许网络在训练过程中学习有意义的表示。</span><br><span class="line">b = torch.zeros(num_outputs,requires_grad=True) #创建一个大小为num_outputs的张量，所有元素都被初始化为0</span><br></pre></td></tr></table></figure><h3 id="定义softmax操作"><a href="#定义softmax操作" class="headerlink" title="定义softmax操作"></a>定义softmax操作</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">X = torch.tensor([[1.0,2.0,3.0],[4.0,5.0,6.0]])#创建了一个包含两行三列的2D张量 X。</span><br><span class="line">X.sum(0,keepdim=True),X.sum(1,keepdim=True)#沿着列（维度0）计算和，同时保持维度。沿着行（维度1）计算和，同时保持维度。</span><br></pre></td></tr></table></figure><p>实现softmax由以下3个步骤组成：</p><ul><li>对每个项求幂（使用exp）</li><li>对每一行求和（小批量中的每个样本是一行），得到每个样本的规范化常数</li><li>将每一行除以其规范化常数，确保结果的和为1</li></ul><p>回顾一下公式：</p><script type="math/tex; mode=display">softmax(X)_{ij} = {\frac{exp(X_{ij})}{\sum_k{exp(X_{ik})}}}</script><p>分母或规范化常数有时也称为配分函数（其对数称为对数-配分函数）。该名称来自统计物理学中一个模拟粒子群分布的方程。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def softmax(X):</span><br><span class="line">    X_exp = torch.exp(X)#对每一项求幂</span><br><span class="line">    partition = X_exp.sum(1,keepdim=True)#对每一行求和，得到每个样本的规范化常数</span><br><span class="line">    return X_exp / partition #这里应用了广播机制</span><br></pre></td></tr></table></figure><p>上述代码，对于任何随机输入，我们将每个元素转变成一个非负数。</p><h3 id="定义模型"><a href="#定义模型" class="headerlink" title="定义模型"></a>定义模型</h3><p>定义输入如何通过网络映射到输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def net(X):</span><br><span class="line">    return softmax(torch.matmul(X.reshape((-1,W.shape[0])),W ) + b)</span><br></pre></td></tr></table></figure><h3 id="定义损失函数"><a href="#定义损失函数" class="headerlink" title="定义损失函数"></a>定义损失函数</h3><p>引入交叉熵损失函数，交叉熵采用实际标签的预测概率的负对数似然。这里我们不使用python的for循环迭代预测（这往往是低效的），而是通过一个运算符选择所有元素。下面，我们创建一个数据样本y_hat，其中包含2个样本在3个类别上的预测概率，以及它们对应的标签y。有了y,我们知道在第一个样本中，第一个类别是正确的预测；而在第二个样本中，第三个类别是正确的预测。然后使用y作为y_hat中的概率索引，我们选择第一个样本中第一个类别的概率和第二个样本中第三个类别的概率</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">y = torch.tensor([0,2])</span><br><span class="line">y_hat = torch.tensor([[0.1,0.3,0.6],[0.3,0.2,0.5]])</span><br><span class="line">y_hat[[0,1],y]#选择第一个样本中第一个类别的概率和第二个样本中第三个类别的概率</span><br></pre></td></tr></table></figure><p>现在完成交叉熵损失函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def cross_entropy(y_hat,y):</span><br><span class="line">    return - torch.log(y_hat[range(len(y_hat)),y])</span><br><span class="line">cross_entropy(y_hat,y)</span><br></pre></td></tr></table></figure><h3 id="分类精度"><a href="#分类精度" class="headerlink" title="分类精度"></a>分类精度</h3><p>给定预测概率分布y_hat，当我们必须输出硬预测时，我们通常选择预测概率最高的类别。当预测与分类标签y一致时是正确的。分类精度是正确预测数与预测总数之比。</p><p>为了计算精度，我们执行以下操作。首先，如果y_hat是矩阵，那么假定第二个维度存储每个类别的预测分数。我们使用argmax获得每行中最大元素的索引来获得预测类别。然后我们将预测类别与真实的y元素进行比较。由于等式运算符“==”对数据类型很敏感，因此我们将y_hat的数据类型转换为与y的数据类型一致。结果是一个包含0（错）和1（对）的张量。最后，我们求和会得到预测正确的数量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def accuracy(y_hat,y):</span><br><span class="line">    &quot;&quot;&quot;计算预测正确的数量&quot;&quot;&quot;</span><br><span class="line">    if len(y_hat.shape) &gt; 1 and y_hat.shape[1] &gt; 1:</span><br><span class="line">        y_hat = y_hat.argmax(axis=1)#使用argmax获得每行中最大元素的索引来获得预测类别</span><br><span class="line">    cmp = y_hat.type(y.dtype) == y</span><br><span class="line">    return float(cmp.type(y.dtype).sum())</span><br><span class="line">accuracy(y_hat,y) / len(y)</span><br></pre></td></tr></table></figure><p>我们将继续使用之前的定义的变量y_hat和y分别作为预测的概率分布和标签。可以看到，第一个样本的预测类别是2（该行的最大元素为0.6，索引为2），这与实际标签0不一致。第二个样本的预测类别是2（该行的最大元素为0.5，索引为2），这与实际标签2一致。因此这两个样本的分类精度为0.5。</p><p>同样对于任意数据迭代器data_iter可访问的数据集，我们可以评估在任意模型net上的精度。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">def evaluate_accuracy(net,data_iter): #@save</span><br><span class="line">    &quot;&quot;&quot;计算在指定数据集上模型的精度&quot;&quot;&quot;</span><br><span class="line">    ##isinstance 是 Python 中的一个内置函数，用于检查一个对象是否是指定类或类型的实例。</span><br><span class="line">    if isinstance(net,torch.nn.Module): #用于检查变量 net 是否是 PyTorch 中的 torch.nn.Module 类的实例</span><br><span class="line">        net.eval() #这一行将模型切换到评估模式。在评估模式下，模型不会计算梯度，这对于推断是很有用的。</span><br><span class="line">    metric = Accumulator(2) #正确预测数、预测总数.创建了一个累加器，用于存储两个值，分别是正确预测数和总预测数。</span><br><span class="line">    # 使用 torch.no_grad() 禁用梯度计算</span><br><span class="line">    with torch.no_grad():</span><br><span class="line">        for X,y in data_iter:</span><br><span class="line">            # 计算当前批次的预测结果</span><br><span class="line">            prediction = net(X)</span><br><span class="line">            metric.add(accuracy(prediction,y),y.numel())#将当前批次的准确度和样本数量添加到累加器中</span><br><span class="line">    return metric[0] / metric[1] #返回模型在整个数据集上的准确度，即累加器中的正确预测数除以总预测数</span><br></pre></td></tr></table></figure><p>这里定义一个使用程序类Accumulator，用于对多个变量进行累加。在上面的evaluate_accuracy函数中，我们在Accumulator实例中创建了两个变量，分别存储正确预测数和预测总数。当我们遍历数据集时，两者都将随着时间的推移而累加。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Accumulator: #@save</span><br><span class="line">    &quot;&quot;&quot;在n个变量上累加&quot;&quot;&quot;</span><br><span class="line">    def __init__(self,n):</span><br><span class="line">        self.data = [0.0] * n</span><br><span class="line">        </span><br><span class="line">    def add(self,*args):</span><br><span class="line">        self.data = [a + float(b) for a,b in zip(self.data,args)]</span><br><span class="line">    def reset(self):</span><br><span class="line">        self.data = [0.0] * len(self.data)</span><br><span class="line">        </span><br><span class="line">    def __getitem__(self,idx):</span><br><span class="line">        return self.data[idx]</span><br></pre></td></tr></table></figure><p>由于我们使用的随机权重初始化，所以模型精度应接近于随机猜测，如若有十个类别，情况下，精度趋向于0.1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">evaluate_accuracy(net,test_iter)</span><br></pre></td></tr></table></figure><h3 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h3><p>首先注意updater是更新模型参数的常用函数，它接收批量大小作为参数。它可以是d2l.sgd函数，也可以是框架的内置优化函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">def train_epoch_ch3(net,train_iter,loss,updater): #@save</span><br><span class="line">    &quot;&quot;&quot;训练模型一轮&quot;&quot;&quot;</span><br><span class="line">    #将模型设置为训练模式</span><br><span class="line">    if isinstance(net,torch.nn.Module):</span><br><span class="line">        net.train()</span><br><span class="line">    #训练损失总和、训练准确度总和、样本数</span><br><span class="line">    metric = Accumulator(3)#创建一个累加器，用于存储三个值</span><br><span class="line">    for X,y in train_iter:</span><br><span class="line">        #计算梯度并更新参数</span><br><span class="line">        y_hat = net(X)</span><br><span class="line">        l = loss(y_hat,y)</span><br><span class="line">        if isinstance(updater,torch.optim.Optimizer):</span><br><span class="line">            #使用Pytorch内置的优化器和损失函数</span><br><span class="line">            updater.zero_grad()</span><br><span class="line">            l.mean().backward()</span><br><span class="line">            updater.step()</span><br><span class="line">        else:</span><br><span class="line">            #使用定制的优化器和损失函数</span><br><span class="line">            l.sum().backward()</span><br><span class="line">            updater(X.shape[0])</span><br><span class="line">        metric.add(float(l.sum()),accuracy(y_hat,y),y.numel())</span><br><span class="line">    #返回训练损失和训练精度</span><br><span class="line">    return metric[0] / metric[2],metric[1] / metric[2]</span><br></pre></td></tr></table></figure><p>定义一个在动画中绘制图表的实用程序类Animator，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">class Animator: #@save</span><br><span class="line">    def __init__(self,xlabel=None,ylabel=None,legend=None,xlim=None,</span><br><span class="line">                ylim=None,xscale=&#x27;linear&#x27;,yscale=&#x27;linear&#x27;,fmts=(&#x27;-&#x27;,&#x27;m--&#x27;,&#x27;g-.&#x27;,&#x27;r:&#x27;),nrows=1,ncols=1,</span><br><span class="line">                figsize=(3.5,2.5)):</span><br><span class="line">        #增量地绘制多条线</span><br><span class="line">        if legend is None:</span><br><span class="line">            legend = []</span><br><span class="line">        d2l.use_svg_display()</span><br><span class="line">        self.fig,self.axes = d2l.plt.subplots(nrows,ncols,figsize=figsize)</span><br><span class="line">        if nrows * ncols == 1:</span><br><span class="line">            self.axes = [self.axes,]</span><br><span class="line">        #使用lambda函数捕获参数</span><br><span class="line">        self.config_axes = lambda : d2l.set_axes(</span><br><span class="line">            self.axes[0],xlabel,ylabel,xlim,ylim,xscale,yscale,legend)</span><br><span class="line">        self.X,self.Y,self.fmts = None,None,fmts</span><br><span class="line">        </span><br><span class="line">    def add(self,x,y):</span><br><span class="line">        #向图表中添加多个数据点</span><br><span class="line">        if not hasattr(y,&quot;__len__&quot;):#目的是检查变量 y 是否是可迭代的（即是否具有长度）,</span><br><span class="line">            #如果 y 可以通过 len(y) 来获取长度，那么返回 True，否则返回 False</span><br><span class="line">            y = [y]</span><br><span class="line">        n = len(y)</span><br><span class="line">        if not hasattr(x,&quot;__len__&quot;):</span><br><span class="line">            x = [x]*n</span><br><span class="line">        if not self.X:</span><br><span class="line">            self.X = [[] for _ in range(n)]</span><br><span class="line">        if not self.Y:</span><br><span class="line">            self.Y = [[] for _ in range(n)]</span><br><span class="line">        for i, (a,b) in enumerate(zip(x,y)):</span><br><span class="line">            if a is not None and b is not None:</span><br><span class="line">                self.X[i].append(a)</span><br><span class="line">                self.Y[i].append(b)</span><br><span class="line">        self.axes[0].cla()</span><br><span class="line">        for x,y,fmt in zip(self.X,self.Y,self.fmts):</span><br><span class="line">            self.axes[0].plot(x,y,fmt)</span><br><span class="line">        self.config_axes()</span><br><span class="line">        display.display(self.fig)</span><br><span class="line">        display.clear_output(wait=True)</span><br></pre></td></tr></table></figure><p>接下来我们实现一个训练函数，它会在train_iter访问的训练数据集上训练一个模型net。该训练函数将会运行多轮（由num_epochs指定）。在每轮结束时，利用test_iter访问的测试数据集对模型进行评估。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">def train_ch3(net,train_iter,test_iter,loss,num_epochs,updater):#@save</span><br><span class="line">    &quot;&quot;&quot;训练模型&quot;&quot;&quot;</span><br><span class="line">     # 创建动画器，用于实时动态绘制图表</span><br><span class="line">    animator = Animator(xlabel=&#x27;epoch&#x27;,xlim=[1,num_epochs],ylim=[0.3,0.9],</span><br><span class="line">                       legend=[&#x27;train loss&#x27;,&#x27;train acc&#x27;,&#x27;test acc&#x27;])</span><br><span class="line">    # 遍历每个 epoch</span><br><span class="line">    for epoch in range(num_epochs):</span><br><span class="line">        # 使用 train_epoch_ch3 函数进行一轮训练，并获取训练指标</span><br><span class="line">        train_metrics = train_epoch_ch3(net,train_iter,loss,updater)</span><br><span class="line">        # 使用 evaluate_accuracy 函数计算在测试集上的准确度</span><br><span class="line">        test_acc = evaluate_accuracy(net,test_iter)</span><br><span class="line">        # 将当前 epoch 的训练损失、训练准确度和测试准确度添加到动画器中</span><br><span class="line">        animator.add(epoch+1,train_metrics + (test_acc,))</span><br><span class="line">    # 获取最后一轮训练的损失和准确度</span><br><span class="line">    train_loss,train_acc = train_metrics</span><br><span class="line">     # 断言用于验证训练和测试的准确度在合理范围内</span><br><span class="line">    assert train_loss &lt; 0.5,train_loss</span><br><span class="line">    assert train_acc &lt;=1 and train_acc &gt; 0.7,train_acc</span><br><span class="line">    assert test_acc &lt;= 1 and test_acc &gt;0.7,test_acc</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lr = 0.1</span><br><span class="line">def updater(batch_size):</span><br><span class="line">    return d2l.sgd([W,b],lr,batch_size)</span><br><span class="line">num_epochs = 10</span><br><span class="line">train_ch3(net,train_iter,test_iter,cross_entropy,num_epochs,updater)</span><br></pre></td></tr></table></figure><h3 id="预测"><a href="#预测" class="headerlink" title="预测"></a>预测</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">def predict_ch3(net,test_iter,n=6):#@save</span><br><span class="line">    &quot;&quot;&quot;预测标签&quot;&quot;&quot;</span><br><span class="line">    # 从测试集中获取一个小批量数据</span><br><span class="line">    for X,y in test_iter:</span><br><span class="line">        break</span><br><span class="line">    # 获取真实标签</span><br><span class="line">    trues = d2l.get_fashion_mnist_labels(y)</span><br><span class="line">    # 使用模型进行预测，并将预测结果转换为标签</span><br><span class="line">    preds = d2l.get_fashion_mnist_labels(net(X).argmax(axis=1))</span><br><span class="line">    # 生成图像标题，包括真实标签和预测标签</span><br><span class="line">    titles = [true + &#x27;\n&#x27; + pred for true,pred in zip(trues,preds)]</span><br><span class="line">     # 可视化预测结果</span><br><span class="line">    d2l.show_images(</span><br><span class="line">        X[0:n].reshape((n,28,28)),1,n,titles = titles[0:n])</span><br><span class="line">predict_ch3(net,test_iter)</span><br></pre></td></tr></table></figure><h2 id="softmax回归简洁实现"><a href="#softmax回归简洁实现" class="headerlink" title="softmax回归简洁实现"></a>softmax回归简洁实现</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from torch import nn</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">batch_size = 256</span><br><span class="line">train_iter,test_iter = d2l.load_data_fashion_mnist(batch_size)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">net = nn.Sequential(nn.Flatten(),nn.Linear(784,10))</span><br><span class="line">def init_weights(m):</span><br><span class="line">    if type(m) == nn.Linear:</span><br><span class="line">        nn.init.normal_(m.weight,std=0.01)</span><br><span class="line">net.apply(init_weights)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loss = nn.CrossEntropyLoss(reduction=&#x27;none&#x27;)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">trainer = torch.optim.SGD(net.parameters(),lr=0.1)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">num_epochs = 10</span><br><span class="line">d2l.train_ch3(net,train_iter,test_iter,loss,num_epochs,trainer)</span><br></pre></td></tr></table></figure><h2 id="课后问题"><a href="#课后问题" class="headerlink" title="课后问题"></a>课后问题</h2><p>增加轮数，为什么测试精度会在一段时间后降低？我们怎么解决这个问题？</p><p>增加迭代周期的数量可能会导致过拟合，从而导致测试精度下降。具体来说，当我们增加迭代周期的数量时，模型可能会开始学习到一些只能满足训练样本的非共性特征（这些更多是一种偶然性特征，不适用于测试样本），从而导致过拟合。为了解决这个问题，可以使用早停技术或正则化技术。早停技术是指在模型出现过拟合时（测试集表现开始下降）停止训练。正则化技术是指通过向损失函数添加惩罚项来限制模型参数的大小，从而减少过拟合。</p>]]></content:encoded>
      
      
      <category domain="https://luckytoadventure.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/">深度学习</category>
      
      
      <category domain="https://luckytoadventure.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/">深度学习</category>
      
      
      <comments>https://luckytoadventure.com/2023/12/28/softmax%E5%9B%9E%E5%BD%92/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>深度学习第二篇——线性神经网络</title>
      <link>https://luckytoadventure.com/2023/12/24/3rd_linear_regression/</link>
      <guid>https://luckytoadventure.com/2023/12/24/3rd_linear_regression/</guid>
      <pubDate>Sun, 24 Dec 2023 07:39:09 GMT</pubDate>
      
      <description>&lt;p&gt;本章主要讲述线性回归。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>本章主要讲述线性回归。</p><span id="more"></span><p>来源：动手学习深度学习(pytorch版)</p><p>向量化加速</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> d2l <span class="keyword">import</span> torch <span class="keyword">as</span> d2l</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">n=<span class="number">10000</span></span><br><span class="line">a = torch.ones(n)</span><br><span class="line">b = torch.ones(n)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#基准测试</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Timer</span>: <span class="comment">#@save</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.times = []</span><br><span class="line">        self.start()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">start</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;启动计时器&quot;&quot;&quot;</span></span><br><span class="line">        self.tik = time.time() <span class="comment">#获取当前时间的时间戳，时间戳是从1970年1月1日零点开始按秒计算的偏移量</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">stop</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;停止计时器并将时间记录在列表中&quot;&quot;&quot;</span></span><br><span class="line">        self.times.append(time.time()-self.tik)</span><br><span class="line">        <span class="keyword">return</span> self.times[-<span class="number">1</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">avg</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;返回平均时间&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(self.times)/<span class="built_in">len</span>(self.times)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Sum</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(self.times)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">cumsum</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;返回累计时间&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> np.array(self.times).cumsum().tolist() <span class="comment">#self.times的列表转换为NumPy数组，然后对数组进行求和操作，并将结果转换为Python列表。</span></span><br><span class="line">        </span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">c = torch.zeros(n)</span><br><span class="line">timer = Timer()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    c[i] = a[i] + b[i]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;timer.stop(): <span class="number">.5</span>f&#125;</span> sec&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="built_in">print</span>(timer.cumsum(),timer.Sum())</span><br></pre></td></tr></table></figure><pre><code> 0.12451 sectensor([2., 2., 2.,  ..., 2., 2., 2.])tensor([1., 1., 1.,  ..., 1., 1., 1.])tensor([1., 1., 1.,  ..., 1., 1., 1.])[0.1245124340057373] 0.1245124340057373</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">timer.start()</span><br><span class="line">d = a + b</span><br><span class="line"><span class="string">f&#x27;<span class="subst">&#123;timer.stop() : <span class="number">.9</span>f&#125;</span> sec&#x27;</span></span><br></pre></td></tr></table></figure><pre><code>&#39; 0.000000000 sec&#39;</code></pre><p>正态分布与平方损失</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">normal</span>(<span class="params">x,mu,sigma</span>):</span><br><span class="line">    p = <span class="number">1</span>/np.sqrt(<span class="number">2</span>*math.pi*sigma**<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> p*np.exp((-<span class="number">0.5</span>/sigma**<span class="number">2</span>)*(x-mu)**<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">x = np.arange(-<span class="number">7</span>,<span class="number">7</span>,<span class="number">0.01</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#均值和标准差对</span></span><br><span class="line">params = [(<span class="number">0</span>,<span class="number">1</span>),(<span class="number">0</span>,<span class="number">2</span>),(<span class="number">3</span>,<span class="number">1</span>)]</span><br><span class="line">d2l.plot(x,[normal(x,mu,sigma) <span class="keyword">for</span> mu,sigma <span class="keyword">in</span> params],xlabel=<span class="string">&#x27;x&#x27;</span>,ylabel=<span class="string">&#x27;p(x)&#x27;</span>,figsize=(<span class="number">4.5</span>,<span class="number">2.5</span>),legend= [<span class="string">f&#x27;mean <span class="subst">&#123;mu&#125;</span>, std <span class="subst">&#123;sigma&#125;</span>&#x27;</span><span class="keyword">for</span> mu,sigma <span class="keyword">in</span> params])</span><br></pre></td></tr></table></figure><p><img src="output_7_0.svg" alt="svg"></p><p>正如我们看到的改变均值会发生沿x轴偏移，增加方差将会分散分布、降低峰值，均方误差损失函数能用于线性回归的一个原因是：我们假设观测中包含噪声，其中噪声服从正态分布。</p><p>小结<br>1.机器学习模型中的关键要素是训练数据集、损失函数、优化算法、以及模型本身。<br>2.向量化使数学表达更简洁，同时计算更快。<br>3.最小化目标函数和执行极大似然估计等价<br>4.线性回归模型也是一个简单的神经网络</p><p> 当数据集较小时，解析解可能比随机梯度下降更好。然而，在大型数据集上，计算解析解可能会非常耗时，或者存在多个局部最小的情况。此外，当矩阵</p><p>⊤</p><p>X<br>⊤<br> X不可逆时，解析解不存在。在这种情况下，需要使用正则化或数值优化方法。</p><p>由于使用了绝对值函数作为损失函数，梯度在接近驻点（即梯度接近零的点）时，梯度不会平滑地趋向于零，而是存在突变。当使用SGD算法，不断更新参数时，可能导致模型无法稳定收敛。</p><p>  解决该问题的方法：</p><p>使用平滑的损失函数，可使用MSE、Smooth L1损失函数等。<br>调整学习率，逐渐减小学习率，使得在驻点附近的参数更新更加稳定<br>使用动量法或自适应学习率优化算法</p><h1 id="从0开始线性回归"><a href="#从0开始线性回归" class="headerlink" title="从0开始线性回归"></a>从0开始线性回归</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline </span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> d2l <span class="keyword">import</span> torch <span class="keyword">as</span> d2l</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">synthetic_data</span>(<span class="params">w,b,num_examples</span>):  <span class="comment">#@save</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;生成y=Xw+b+噪声&quot;&quot;&quot;</span></span><br><span class="line">    x = torch.normal(<span class="number">0</span>,<span class="number">1</span>,(num_examples,<span class="built_in">len</span>(w))) <span class="comment">#num_examples表示有几个样本，即有几行。len(w)表示有与w行数相同的属性数即列数</span></span><br><span class="line">    y = torch.matmul(x,w)+b</span><br><span class="line">    y += torch.normal(<span class="number">0</span>,<span class="number">0.01</span>,y.shape) <span class="comment">#加上噪声</span></span><br><span class="line">    <span class="keyword">return</span> x,y.reshape((-<span class="number">1</span>,<span class="number">1</span>))  <span class="comment">#(-1, 1)表示将数组y在第一个维度上展开，第二个维度保持不变,此例中将y转为列向量</span></span><br><span class="line"></span><br><span class="line">true_w = torch.tensor([<span class="number">2</span>,-<span class="number">3.4</span>])</span><br><span class="line">true_b = <span class="number">4.2</span></span><br><span class="line">features, labels = synthetic_data(true_w,true_b,<span class="number">1000</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;features:&#x27;</span>,features[<span class="number">0</span>],<span class="string">&#x27;\nlabels:&#x27;</span>,labels[<span class="number">0</span>]) <span class="comment">#features中每一行都包含一个二维样本，labels每一行都包含一个一维标量</span></span><br></pre></td></tr></table></figure><pre><code>features: tensor([-1.5115, -2.4289]) labels: tensor([9.4437])</code></pre><p>生成features的第二个特征与labels之间的线性关系</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d2l.set_figsize() <span class="comment">#设置图形的宽度和高度</span></span><br><span class="line">d2l.plt.scatter(features[:,<span class="number">1</span>].detach().numpy(),labels.detach().numpy(),<span class="number">1</span>) <span class="comment">#labels.detach()返回的新张量与原始张量共享数据,而numpy则是将之转为数组</span></span><br></pre></td></tr></table></figure><pre><code>&lt;matplotlib.collections.PathCollection at 0x230fd7fe130&gt;</code></pre><p><img src="output_16_1.svg" alt="svg"></p><p>读取数据集</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">data_iter</span>(<span class="params">batch_size,features,labels</span>): <span class="comment">#batch_size为每次读取的批量大小</span></span><br><span class="line">    num_examples = <span class="built_in">len</span>(features)</span><br><span class="line">    indices = <span class="built_in">list</span>(<span class="built_in">range</span>(num_examples)) </span><br><span class="line">    <span class="comment"># 这些样本是随机读取的，没有特定的顺序</span></span><br><span class="line">    random.shuffle(indices) <span class="comment">#用于将列表中的元素随机打乱</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,num_examples,batch_size):</span><br><span class="line">        batch_indices = torch.tensor(indices[i:<span class="built_in">min</span>(i + batch_size,num_examples)]) <span class="comment">#每次取batch_size个，若是满了，则取num_examples-i+1个</span></span><br><span class="line">        <span class="keyword">yield</span> features[batch_indices],labels[batch_indices]</span><br></pre></td></tr></table></figure><p>yield关键字用于定义生成器函数。生成器函数是一种特殊的迭代器，它允许你在函数执行过程中暂停和恢复，从而节省内存。当你调用一个生成器函数时，它会返回一个生成器对象，而不是直接执行函数体。要获取生成器的下一个值，你需要使用next()函数或者在循环中使用for语句。features[batch_indices]和labels[batch_indices]。这两个列表分别包含了当前批次的特征和标签。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">batch_size = <span class="number">10</span></span><br><span class="line"><span class="keyword">for</span> X, y <span class="keyword">in</span> data_iter(batch_size,features,labels):</span><br><span class="line">    <span class="built_in">print</span>(X,<span class="string">&quot;\n&quot;</span>,y)</span><br><span class="line">    <span class="keyword">break</span></span><br></pre></td></tr></table></figure><pre><code>tensor([[-1.7161,  0.5275],        [ 0.5354, -0.6246],        [ 0.8205,  0.0515],        [-2.5739,  1.4279],        [ 0.8007,  0.0255],        [ 0.4949,  0.1812],        [-0.4580,  0.1285],        [-0.7347,  0.9106],        [-0.7922, -0.7991],        [-0.6561,  0.4373]])  tensor([[-1.0201],        [ 7.3861],        [ 5.6638],        [-5.8160],        [ 5.7303],        [ 4.5611],        [ 2.8534],        [-0.3845],        [ 5.3452],        [ 1.3960]])</code></pre><p>初始化模型参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#初始化权重，并将偏置为0</span></span><br><span class="line">w = torch.normal(<span class="number">0</span>,<span class="number">0.01</span>,size=(<span class="number">2</span>,<span class="number">1</span>),requires_grad=<span class="literal">True</span>)</span><br><span class="line">b = torch.zeros(<span class="number">1</span>,requires_grad=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义模型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">linreg</span>(<span class="params">X,w,b</span>): <span class="comment">#@save</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;线性回归模型&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> torch.matmul(X,w)+b</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义损失函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">squared_loss</span>(<span class="params">y_hat,y</span>): <span class="comment">#@save</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;均方损失&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> (y_hat-y.reshape(y_hat.shape))**<span class="number">2</span>/<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#定义优化算法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sgd</span>(<span class="params">params,lr,batch_size</span>): <span class="comment">#@save</span></span><br><span class="line">    <span class="comment">#params:参数集合，lr：学习率，batch_size:批量大小</span></span><br><span class="line">    <span class="keyword">with</span> torch.no_grad(): <span class="comment">#是PyTorch中的一个上下文管理器，用于在计算图中禁用梯度计算</span></span><br><span class="line">        <span class="keyword">for</span> param <span class="keyword">in</span> params:</span><br><span class="line">            param -= lr * param.grad / batch_size <span class="comment">#每一步更新大小由学习率lr决定，用批量答案小来规范步长，这样步长就不会取决于批量大小</span></span><br><span class="line">            param.grad.zero_() <span class="comment">#将参数梯度清零</span></span><br><span class="line"></span><br><span class="line">lr = <span class="number">0.03</span></span><br><span class="line">num_epochs = <span class="number">3</span> <span class="comment">#共三轮总遍历</span></span><br><span class="line">net = linreg</span><br><span class="line">loss = squared_loss</span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(num_epochs):</span><br><span class="line">    <span class="keyword">for</span> X,y <span class="keyword">in</span> data_iter(batch_size,features,labels):</span><br><span class="line">        l = loss(net(X,w,b),y) <span class="comment"># X和y的小批量损失，net(X,w,b)用于计算神经网络的输出。其中，X是输入数据，w是权重矩阵，b是偏置向量。\</span></span><br><span class="line">        <span class="comment">#这个函数通常用于前向传播过程，即将输入数据通过神经网络进行计算，得到输出结果。</span></span><br><span class="line">        <span class="comment">#这里的X是一个二维数组，每一行代表一个样本，每一列代表一个特征；</span></span><br><span class="line">        <span class="comment">#因为l的形状是(batch_size,1),不是一个标量</span></span><br><span class="line">        <span class="comment">#l中的所有元素被加到一起，并以此计算关于[w,b]的梯度</span></span><br><span class="line">        l.<span class="built_in">sum</span>().backward()</span><br><span class="line">        sgd([w,b], lr, batch_size) <span class="comment">#使用参数的梯度更新参数</span></span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        train_l = loss(net(features,w,b),labels)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;epoch <span class="subst">&#123;epoch+<span class="number">1</span>&#125;</span>,loss <span class="subst">&#123;<span class="built_in">float</span>(train_l.mean()): f&#125;</span>&#x27;</span>)</span><br><span class="line">    </span><br></pre></td></tr></table></figure><pre><code>epoch 1,loss  0.044458epoch 2,loss  0.000173epoch 3,loss  0.000050</code></pre>]]></content:encoded>
      
      
      <category domain="https://luckytoadventure.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/">深度学习</category>
      
      
      <category domain="https://luckytoadventure.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/">深度学习</category>
      
      
      <comments>https://luckytoadventure.com/2023/12/24/3rd_linear_regression/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>深度学习第一篇——数据预处理</title>
      <link>https://luckytoadventure.com/2023/12/24/2nd_Data_preprocessing/</link>
      <guid>https://luckytoadventure.com/2023/12/24/2nd_Data_preprocessing/</guid>
      <pubDate>Sun, 24 Dec 2023 07:38:46 GMT</pubDate>
      
      <description>&lt;p&gt;本章主要讲述数据预处理。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>本章主要讲述数据预处理。</p><span id="more"></span><p>来源：动手学习深度学习(pytorch版)</p><h1 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建数据集</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.makedirs(os.path.join(<span class="string">&#x27;..&#x27;</span>,<span class="string">&#x27;data&#x27;</span>),exist_ok=<span class="literal">True</span>)</span><br><span class="line">data_file =os.path.join(<span class="string">&#x27;..&#x27;</span>,<span class="string">&#x27;data&#x27;</span>,<span class="string">&#x27;house_tiny.csv&#x27;</span>)</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(data_file,<span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(<span class="string">&#x27;NumRooms,Alley,Price\n&#x27;</span>) <span class="comment">#列名</span></span><br><span class="line">    f.write(<span class="string">&#x27;NA,Pave,127500\n&#x27;</span>) <span class="comment">#每行表示一个数据样本</span></span><br><span class="line">    f.write(<span class="string">&#x27;2,NA,106000\n&#x27;</span>)</span><br><span class="line">    f.write(<span class="string">&#x27;4,NA,178100\n&#x27;</span>)</span><br><span class="line">    f.write(<span class="string">&#x27;NA,NA,140000\n&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">data=pd.read_csv(data_file)</span><br><span class="line"><span class="built_in">print</span>(data)</span><br></pre></td></tr></table></figure><pre><code>   NumRooms Alley   Price0       NaN  Pave  1275001       2.0   NaN  1060002       4.0   NaN  1781003       NaN   NaN  140000</code></pre><h2 id="处理缺失值"><a href="#处理缺失值" class="headerlink" title="处理缺失值"></a>处理缺失值</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#NAN代表缺失值</span></span><br><span class="line"><span class="comment">#通过iloc，我们将data分成inputs和outputs</span></span><br><span class="line">inputs,outputs = data.iloc[:,<span class="number">0</span>:<span class="number">1</span>],data.iloc[:,<span class="number">2</span>]</span><br><span class="line">inputs = inputs.fillna(inputs.mean())</span><br><span class="line"><span class="built_in">print</span>(inputs)</span><br></pre></td></tr></table></figure><pre><code>   NumRooms0       3.01       2.02       4.03       3.0</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">inputs1=data.iloc[:,<span class="number">1</span>:<span class="number">2</span>]</span><br><span class="line">inputs = pd.concat([inputs,inputs1],axis=<span class="number">1</span>)</span><br><span class="line">inputs</span><br></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>NumRooms</th>      <th>Alley</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>3.0</td>      <td>Pave</td>    </tr>    <tr>      <th>1</th>      <td>2.0</td>      <td>NaN</td>    </tr>    <tr>      <th>2</th>      <td>4.0</td>      <td>NaN</td>    </tr>    <tr>      <th>3</th>      <td>3.0</td>      <td>NaN</td>    </tr>  </tbody></table></div><h2 id="我们将NaN视为一个类别，由于Alley列只接受两种类型的类别值Pave和NaN-pandas可以自动将此列转换为两列Alley-Pave和Alley-NaN"><a href="#我们将NaN视为一个类别，由于Alley列只接受两种类型的类别值Pave和NaN-pandas可以自动将此列转换为两列Alley-Pave和Alley-NaN" class="headerlink" title="我们将NaN视为一个类别，由于Alley列只接受两种类型的类别值Pave和NaN,pandas可以自动将此列转换为两列Alley_Pave和Alley_NaN"></a>我们将NaN视为一个类别，由于Alley列只接受两种类型的类别值Pave和NaN,pandas可以自动将此列转换为两列Alley_Pave和Alley_NaN</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">inputs = pd.get_dummies(inputs,dummy_na=<span class="literal">True</span>,dtype=<span class="built_in">int</span>) <span class="comment"># dtype=int为了将原本返回的逻辑值转为int型</span></span><br><span class="line"><span class="built_in">print</span>(inputs)</span><br></pre></td></tr></table></figure><pre><code>   NumRooms  Alley_Pave  Alley_nan0       3.0           1          01       2.0           0          12       4.0           0          13       3.0           0          1</code></pre><h2 id="转换为张量格式"><a href="#转换为张量格式" class="headerlink" title="转换为张量格式"></a>转换为张量格式</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line">X,y = torch.tensor(inputs.values),torch.tensor(outputs.values)</span><br><span class="line">X,y</span><br></pre></td></tr></table></figure><pre><code>(tensor([[3., 1., 0.],         [2., 0., 1.],         [4., 0., 1.],         [3., 0., 1.]], dtype=torch.float64), tensor([127500, 106000, 178100, 140000]))</code></pre><h1 id="线性代数"><a href="#线性代数" class="headerlink" title="线性代数"></a>线性代数</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#标量</span></span><br><span class="line">x = torch.tensor(<span class="number">3.0</span>)</span><br><span class="line">y = torch.tensor(<span class="number">2.0</span>)</span><br><span class="line">x + y, x * y, x / y, x**y</span><br></pre></td></tr></table></figure><pre><code>(tensor(5.), tensor(6.), tensor(1.5000), tensor(9.))</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#向量</span></span><br><span class="line">x = torch.arange(<span class="number">4</span>)</span><br><span class="line">x</span><br></pre></td></tr></table></figure><pre><code>tensor([0, 1, 2, 3])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x[<span class="number">3</span>] <span class="comment">#访问任意元素</span></span><br></pre></td></tr></table></figure><pre><code>tensor(3)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">len</span>(x) <span class="comment">#数组长度</span></span><br></pre></td></tr></table></figure><pre><code>4</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x.shape <span class="comment">#向量形状</span></span><br></pre></td></tr></table></figure><pre><code>torch.Size([4])</code></pre><h2 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A = torch.arange(<span class="number">20</span>).reshape(<span class="number">5</span>,<span class="number">4</span>)</span><br><span class="line">A</span><br></pre></td></tr></table></figure><pre><code>tensor([[ 0,  1,  2,  3],        [ 4,  5,  6,  7],        [ 8,  9, 10, 11],        [12, 13, 14, 15],        [16, 17, 18, 19]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#矩阵转置</span></span><br><span class="line">A.T</span><br></pre></td></tr></table></figure><pre><code>tensor([[ 0,  4,  8, 12, 16],        [ 1,  5,  9, 13, 17],        [ 2,  6, 10, 14, 18],        [ 3,  7, 11, 15, 19]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">B = torch.tensor([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">0</span>,<span class="number">4</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]]) <span class="comment"># 对称矩阵</span></span><br><span class="line">B , B == B.T</span><br></pre></td></tr></table></figure><pre><code>(tensor([[1, 2, 3],         [2, 0, 4],         [3, 4, 5]]), tensor([[True, True, True],         [True, True, True],         [True, True, True]]))</code></pre><h3 id="张量"><a href="#张量" class="headerlink" title="张量"></a>张量</h3><pre><code>##当我们处理图像时，张量将变得更加重要，图像以n维数组形式出现，其中3个轴对应于高度,宽度，以及一个通道用于表示颜色通道（红色，绿色和蓝色）。</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">X = torch.arange(<span class="number">24</span>).reshape(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">X, <span class="built_in">len</span>(X)</span><br></pre></td></tr></table></figure><pre><code>(tensor([[[ 0,  1,  2,  3],          [ 4,  5,  6,  7],          [ 8,  9, 10, 11]],         [[12, 13, 14, 15],          [16, 17, 18, 19],          [20, 21, 22, 23]]]), 2)</code></pre><h3 id="张量算法的基本性质"><a href="#张量算法的基本性质" class="headerlink" title="张量算法的基本性质"></a>张量算法的基本性质</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A = torch.arange(<span class="number">20</span>,dtype=torch.float32).reshape(<span class="number">5</span>,<span class="number">4</span>)</span><br><span class="line">B = A.clone() <span class="comment"># 通过分配新内存，将A的一个副本分配给B</span></span><br><span class="line">A, A + B <span class="comment"># 对于相同形状的矩阵，按元素的二元运算结果都将是形状相同的张量</span></span><br></pre></td></tr></table></figure><pre><code>(tensor([[ 0.,  1.,  2.,  3.],         [ 4.,  5.,  6.,  7.],         [ 8.,  9., 10., 11.],         [12., 13., 14., 15.],         [16., 17., 18., 19.]]), tensor([[ 0.,  2.,  4.,  6.],         [ 8., 10., 12., 14.],         [16., 18., 20., 22.],         [24., 26., 28., 30.],         [32., 34., 36., 38.]]))</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A * B <span class="comment"># 按照元素乘，称为哈达玛积</span></span><br></pre></td></tr></table></figure><pre><code>tensor([[  0.,   1.,   4.,   9.],        [ 16.,  25.,  36.,  49.],        [ 64.,  81., 100., 121.],        [144., 169., 196., 225.],        [256., 289., 324., 361.]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">2</span></span><br><span class="line">X = torch.arange(<span class="number">24</span>).reshape(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">a + X, (a * X).shape</span><br></pre></td></tr></table></figure><pre><code>(tensor([[[ 2,  3,  4,  5],          [ 6,  7,  8,  9],          [10, 11, 12, 13]],         [[14, 15, 16, 17],          [18, 19, 20, 21],          [22, 23, 24, 25]]]), torch.Size([2, 3, 4]))</code></pre><h3 id="降维"><a href="#降维" class="headerlink" title="降维"></a>降维</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = torch.arange(<span class="number">4</span>,dtype=torch.float32)</span><br><span class="line">x, x.<span class="built_in">sum</span>() <span class="comment"># 会计算其所有元素的和</span></span><br></pre></td></tr></table></figure><pre><code>(tensor([0., 1., 2., 3.]), tensor(6.))</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A.shape, A.<span class="built_in">sum</span>()</span><br></pre></td></tr></table></figure><pre><code>(torch.Size([5, 4]), tensor(190.))</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#指定某个轴降低维度</span></span><br><span class="line">A_sum_axis0=A.<span class="built_in">sum</span>(axis=<span class="number">0</span>)</span><br><span class="line">A_sum_axis0,A_sum_axis0.shape</span><br></pre></td></tr></table></figure><pre><code>(tensor([40., 45., 50., 55.]), torch.Size([4]))</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A_sum_axis1 = A.<span class="built_in">sum</span>(axis=<span class="number">1</span>)</span><br><span class="line">A_sum_axis1, A_sum_axis1.shape</span><br></pre></td></tr></table></figure><pre><code>(tensor([ 6., 22., 38., 54., 70.]), torch.Size([5]))</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 沿行和列对矩阵求和，等价于对矩阵的所有元素求和</span></span><br><span class="line">A.<span class="built_in">sum</span>(axis=[<span class="number">0</span>,<span class="number">1</span>]) <span class="comment"># 结果和A.sum()相同</span></span><br></pre></td></tr></table></figure><pre><code>tensor(190.)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A.mean(), A.<span class="built_in">sum</span>() / A.numel()</span><br></pre></td></tr></table></figure><pre><code>(tensor(9.5000), tensor(9.5000))</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A.mean(axis=<span class="number">0</span>), A.<span class="built_in">sum</span>(axis=<span class="number">0</span>) / A.shape[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><pre><code>(tensor([ 8.,  9., 10., 11.]), tensor([ 8.,  9., 10., 11.]))</code></pre><h4 id="非降维求和"><a href="#非降维求和" class="headerlink" title="非降维求和"></a>非降维求和</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sum_A = A.<span class="built_in">sum</span>(axis=<span class="number">1</span>,keepdims=<span class="literal">True</span>)</span><br><span class="line">sum_A</span><br></pre></td></tr></table></figure><pre><code>tensor([[ 6.],        [22.],        [38.],        [54.],        [70.]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A / sum_A</span><br></pre></td></tr></table></figure><pre><code>tensor([[0.0000, 0.1667, 0.3333, 0.5000],        [0.1818, 0.2273, 0.2727, 0.3182],        [0.2105, 0.2368, 0.2632, 0.2895],        [0.2222, 0.2407, 0.2593, 0.2778],        [0.2286, 0.2429, 0.2571, 0.2714]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A.cumsum(axis=<span class="number">0</span>) <span class="comment">#累积总和</span></span><br></pre></td></tr></table></figure><pre><code>tensor([[ 0.,  1.,  2.,  3.],        [ 4.,  6.,  8., 10.],        [12., 15., 18., 21.],        [24., 28., 32., 36.],        [40., 45., 50., 55.]])</code></pre><h4 id="点积"><a href="#点积" class="headerlink" title="点积"></a>点积</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">y = torch.ones(<span class="number">4</span>,dtype = torch.float32)</span><br><span class="line">x, y, torch.dot(x,y)</span><br></pre></td></tr></table></figure><pre><code>(tensor([0., 1., 2., 3.]), tensor([1., 1., 1., 1.]), tensor(6.))</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#也可以通过执行按元素相乘后求和</span></span><br><span class="line">torch.<span class="built_in">sum</span>(x*y)</span><br></pre></td></tr></table></figure><pre><code>tensor(6.)</code></pre><h4 id="矩阵-向量积"><a href="#矩阵-向量积" class="headerlink" title="矩阵-向量积"></a>矩阵-向量积</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#线代中的矩阵乘以向量 m*n*n*1=m*1</span></span><br><span class="line">A.shape, x.shape, torch.mv(A,x)</span><br></pre></td></tr></table></figure><pre><code>(torch.Size([5, 4]), torch.Size([4]), tensor([ 14.,  38.,  62.,  86., 110.]))</code></pre><p>矩阵-矩阵乘法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">B = torch.ones(<span class="number">4</span>,<span class="number">3</span>)</span><br><span class="line">torch.mm(A,B) <span class="comment">#与哈达玛积不同</span></span><br></pre></td></tr></table></figure><pre><code>tensor([[ 6.,  6.,  6.],        [22., 22., 22.],        [38., 38., 38.],        [54., 54., 54.],        [70., 70., 70.]])</code></pre><h4 id="范数"><a href="#范数" class="headerlink" title="范数"></a>范数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u = torch.tensor([<span class="number">3.0</span>,-<span class="number">4.0</span>])</span><br><span class="line">torch.norm(u) <span class="comment"># L2范数</span></span><br></pre></td></tr></table></figure><pre><code>tensor(5.)</code></pre><p>L1范数是取绝对值相加，L2范数是取平方相加后开平方，Lp范数是对每个值取p次方之后相加的和开p次方</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.<span class="built_in">abs</span>(u).<span class="built_in">sum</span>() <span class="comment"># L1范数</span></span><br></pre></td></tr></table></figure><pre><code>tensor(7.)</code></pre><p>费罗贝尼乌斯范数是矩阵元素平方和的平方根</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.norm(torch.ones((<span class="number">4</span>,<span class="number">9</span>)))</span><br></pre></td></tr></table></figure><pre><code>tensor(6.)</code></pre><h2 id="微积分"><a href="#微积分" class="headerlink" title="微积分"></a>微积分</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib_inline <span class="keyword">import</span> backend_inline</span><br><span class="line"><span class="keyword">from</span> d2l <span class="keyword">import</span> torch <span class="keyword">as</span> d2l</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span>*x**<span class="number">2</span>-<span class="number">4</span>*x</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">numerical_lim</span>(<span class="params">f,x,h</span>):</span><br><span class="line">    <span class="keyword">return</span> (f(x+h)-f(x))/h</span><br><span class="line">h=<span class="number">0.1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;h=<span class="subst">&#123;h:<span class="number">.5</span>f&#125;</span>,numerocal limit = <span class="subst">&#123;numerical_lim(f,<span class="number">1</span>,h):<span class="number">.5</span>f&#125;</span>&#x27;</span>)</span><br><span class="line">    h*=<span class="number">0.1</span></span><br></pre></td></tr></table></figure><pre><code>h=0.10000,numerocal limit = 2.30000h=0.01000,numerocal limit = 2.03000h=0.00100,numerocal limit = 2.00300h=0.00010,numerocal limit = 2.00030h=0.00001,numerocal limit = 2.00003</code></pre><p>use_svg_display函数指定matplotlib包输出svg图表以获得更清晰的图像</p><h1 id="save是一个特殊的标记，会将对应的函数、类或语句保存在d2l包中"><a href="#save是一个特殊的标记，会将对应的函数、类或语句保存在d2l包中" class="headerlink" title="@save是一个特殊的标记，会将对应的函数、类或语句保存在d2l包中"></a>@save是一个特殊的标记，会将对应的函数、类或语句保存在d2l包中</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">use_svg_display</span>(): <span class="comment">#@save</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;使用svg格式在jupyter中显示绘图&quot;&quot;&quot;</span></span><br><span class="line">    backend_inline.set_matplotlib_formats(<span class="string">&#x27;svg&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">set_figsize</span>(<span class="params">figsize=(<span class="params"><span class="number">3.5</span>,<span class="number">2.5</span></span>)</span>): <span class="comment">#@save</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;设置matplotlib的图表大小&quot;&quot;&quot;</span></span><br><span class="line">    use_svg_display()</span><br><span class="line">    d2l.plt.rcParams[<span class="string">&#x27;figure.figsize&#x27;</span>] = figsize</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#@save</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">set_axes</span>(<span class="params">axes,xlabel,ylabel,xlim,ylim,xscale,yscale,legend</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;设置matplotlib的轴&quot;&quot;&quot;</span></span><br><span class="line">    axes.set_xlabel(xlabel)</span><br><span class="line">    axes.set_ylabel(ylabel)</span><br><span class="line">    axes.set_xscale(xscale)</span><br><span class="line">    axes.set_yscale(yscale)</span><br><span class="line">    axes.set_xlim(xlim)</span><br><span class="line">    axes.set_ylim(ylim)</span><br><span class="line">    <span class="keyword">if</span> legend:</span><br><span class="line">        axes.legend(legend)</span><br><span class="line">    axes.grid()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#@save</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">plot</span>(<span class="params">X, Y=<span class="literal">None</span>,xlabel=<span class="literal">None</span>,ylabel=<span class="literal">None</span>,legend=<span class="literal">None</span>,xlim=<span class="literal">None</span>,</span></span><br><span class="line"><span class="params">        ylim=<span class="literal">None</span>,xscale=<span class="string">&#x27;linear&#x27;</span>,yscale=<span class="string">&#x27;linear&#x27;</span>,</span></span><br><span class="line"><span class="params">        fmts=(<span class="params"><span class="string">&#x27;-&#x27;</span>,<span class="string">&#x27;m--&#x27;</span>,<span class="string">&#x27;g-.&#x27;</span>,<span class="string">&#x27;r:&#x27;</span></span>),figsize=(<span class="params"><span class="number">3.5</span>,<span class="number">2.5</span></span>),axes=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;绘制数据点&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> legend <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        legend = []</span><br><span class="line">    set_figsize(figsize)</span><br><span class="line">    axes = axes <span class="keyword">if</span> axes <span class="keyword">else</span> d2l.plt.gca()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 如果X有一个轴，输出True</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">has_one_axis</span>(<span class="params">X</span>):</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">hasattr</span>(X,<span class="string">&quot;ndim&quot;</span>) <span class="keyword">and</span> X.ndim == <span class="number">1</span> <span class="keyword">or</span> <span class="built_in">isinstance</span>(X,<span class="built_in">list</span>)</span><br><span class="line">               <span class="keyword">and</span> <span class="keyword">not</span> <span class="built_in">hasattr</span>(X[<span class="number">0</span>],<span class="string">&quot;__len__&quot;</span>))</span><br><span class="line">    <span class="keyword">if</span> has_one_axis(X):</span><br><span class="line">        X = [X]</span><br><span class="line">    <span class="keyword">if</span> Y <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        X, Y = [[]]*<span class="built_in">len</span>(X),X</span><br><span class="line">    <span class="keyword">elif</span> has_one_axis(Y):</span><br><span class="line">        Y = [Y]</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(X) != <span class="built_in">len</span>(Y):</span><br><span class="line">        X = X * <span class="built_in">len</span>(Y)</span><br><span class="line">    axes.cla()</span><br><span class="line">    <span class="keyword">for</span> x,y,fmt <span class="keyword">in</span> <span class="built_in">zip</span>(X,Y,fmts):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(x):</span><br><span class="line">            axes.plot(x,y,fmt)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            axes.plot(y,fmt)</span><br><span class="line">    set_axes(axes,xlabel,ylabel,xlim,ylim,xscale,yscale,legend)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = np.arange(<span class="number">0</span>,<span class="number">3</span>,<span class="number">0.1</span>)</span><br><span class="line">plot(x,[f(x),<span class="number">2</span>*x-<span class="number">3</span>],<span class="string">&#x27;x&#x27;</span>,<span class="string">&#x27;f(x)&#x27;</span>,legend=[<span class="string">&#x27;f(x)&#x27;</span>,<span class="string">&#x27;Tangent line (x=1)&#x27;</span>])</span><br></pre></td></tr></table></figure><p><img src="output_59_0.svg" alt="svg"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x**<span class="number">3</span>-<span class="number">1</span>/x</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f_tangent</span>(<span class="params">f,x,point</span>):</span><br><span class="line">    h=<span class="number">1e-4</span></span><br><span class="line">    grad=(f(h+point)-f(point))/h</span><br><span class="line">    <span class="keyword">return</span> grad*(x-point)+f(point)</span><br><span class="line">x=np.arange(<span class="number">0.1</span>,<span class="number">2.0</span>,<span class="number">0.01</span>)</span><br><span class="line">y=f(x)</span><br><span class="line">y_tangent=f_tangent(f,x,<span class="number">1</span>)</span><br><span class="line">plt.plot(x,y,label=<span class="string">&quot;f(x)&quot;</span>)</span><br><span class="line">plt.plot(x,y_tangent,label=<span class="string">&quot;Tangent line at x=1&quot;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.title(<span class="string">&#x27;Graph of f(x) and its tangent line at x=1&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;X&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Y&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="output_60_0.svg" alt="svg"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#利用代码验证</span></span><br><span class="line"><span class="comment">#requires_grad设置为true，它将开始追踪在其上的所有操作，这样就可以利用链式法则进行梯度传播</span></span><br><span class="line">x = torch.arange(<span class="number">2.0</span>,requires_grad=<span class="literal">True</span>) <span class="comment"># 将梯度附加到其想要计算的偏导数的变量</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#例一</span></span><br><span class="line"><span class="comment">#grad_fn 该属性即创建该Tensor的Function,就是说该Tensor是不是通过某些运算得到的，若是，则grad_fn返回与这些运算相关的对象，否则是None</span></span><br><span class="line">x = torch.ones(<span class="number">2</span>,<span class="number">2</span>,requires_grad=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"><span class="built_in">print</span>(x.grad_fn)</span><br></pre></td></tr></table></figure><pre><code>tensor([[1., 1.],        [1., 1.]], requires_grad=True)None</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#例二</span></span><br><span class="line">x = torch.ones(<span class="number">2</span>,<span class="number">2</span>,requires_grad=<span class="literal">True</span>)</span><br><span class="line">y = x + <span class="number">2</span></span><br><span class="line"><span class="built_in">print</span>(y)</span><br><span class="line"><span class="built_in">print</span>(y.grad_fn)</span><br></pre></td></tr></table></figure><pre><code>tensor([[3., 3.],        [3., 3.]], grad_fn=&lt;AddBackward0&gt;)&lt;AddBackward0 object at 0x000002278E2D5D00&gt;</code></pre><p>is_leaf说明<br>注意像x是直接创建的，所以他没有grad_fn，而y是通过一个加法操作创建的，所以他有一个grad_fn<br>像x这种直接创建的称为叶子节点，叶子节点对应的grad_fn是None</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(x.is_leaf,y.is_leaf)</span><br></pre></td></tr></table></figure><pre><code>True False</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#另一种改变requires_grad的方法</span></span><br><span class="line">a = torch.randn(<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">a=((a*<span class="number">3</span>)/(a-<span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(a.requires_grad)</span><br><span class="line">a.requires_grad_(<span class="literal">True</span>)</span><br><span class="line">y=(a*a).<span class="built_in">sum</span>()</span><br><span class="line"><span class="built_in">print</span>(y)</span><br><span class="line"><span class="built_in">print</span>(y.requires_grad)</span><br></pre></td></tr></table></figure><pre><code>tensor([[ 0.5309, -0.5969],        [-0.9133, -1.4638]])tensor([[-3.3949,  1.1214],        [ 1.4320,  1.7824]])Falsetensor(18.0100, grad_fn=&lt;SumBackward0&gt;)True</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#使用backward()计算梯度</span></span><br><span class="line"><span class="comment">#注意在使用y.backward()时，若y时标量，则可以直接计算，否则需利用torch传入一个与y相同维度的tensor</span></span><br><span class="line">x = torch.ones(<span class="number">2</span>,<span class="number">2</span>,requires_grad=<span class="literal">True</span>)</span><br><span class="line">y = x+<span class="number">2</span></span><br><span class="line">z = y*y*<span class="number">3</span></span><br><span class="line">out = z.mean()</span><br><span class="line"><span class="built_in">print</span>(z)</span><br><span class="line"><span class="built_in">print</span>(out)</span><br><span class="line">out.backward()</span><br><span class="line"><span class="built_in">print</span>(x.grad)</span><br></pre></td></tr></table></figure><pre><code>tensor([[27., 27.],        [27., 27.]], grad_fn=&lt;MulBackward0&gt;)tensor(27., grad_fn=&lt;MeanBackward0&gt;)tensor([[4.5000, 4.5000],        [4.5000, 4.5000]])</code></pre><p>grad_zero说明<br>该函数用来清除x的梯度，也就是重新赋值为0。需要注意的是，只有当x被求过一次梯度时，这个函数才能使用，否则会报错</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#再来一次反向传播，注意grad是累加的</span></span><br><span class="line">out2 = x.<span class="built_in">sum</span>()</span><br><span class="line"><span class="built_in">print</span>(out2)</span><br><span class="line">out2.backward()</span><br><span class="line"><span class="built_in">print</span>(x.grad)</span><br><span class="line"></span><br><span class="line">out3 = x.<span class="built_in">sum</span>()</span><br><span class="line">x.grad.zero_()</span><br><span class="line">out3.backward()</span><br><span class="line"><span class="built_in">print</span>(x.grad)</span><br></pre></td></tr></table></figure><pre><code>tensor(4., grad_fn=&lt;SumBackward0&gt;)tensor([[5.5000, 5.5000],        [5.5000, 5.5000]])tensor([[1., 1.],        [1., 1.]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://luckytoadventure.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/">深度学习</category>
      
      
      <category domain="https://luckytoadventure.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/">深度学习</category>
      
      
      <comments>https://luckytoadventure.com/2023/12/24/2nd_Data_preprocessing/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>深度学习第一篇——预备知识</title>
      <link>https://luckytoadventure.com/2023/12/24/1st_Get_started/</link>
      <guid>https://luckytoadventure.com/2023/12/24/1st_Get_started/</guid>
      <pubDate>Sun, 24 Dec 2023 07:35:33 GMT</pubDate>
      
      <description>&lt;p&gt;本章主要讲述一些入门操作。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>本章主要讲述一些入门操作。</p><span id="more"></span><p>来源：动手学习深度学习(pytorch版)</p><p>张量表示一个由数值组成的数组，这个数组可能有多个维度。具有一个轴的张量对应数学上的向量。<br>使用arange创建一个行向量x.从0开始。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x=torch.arange(<span class="number">12</span>)</span><br><span class="line">x</span><br></pre></td></tr></table></figure><pre><code>tensor([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])</code></pre><p>输出张量的形状</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x.shape</span><br></pre></td></tr></table></figure><pre><code>torch.Size([12])</code></pre><p>检查张量的大小</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x.numel()</span><br></pre></td></tr></table></figure><pre><code>12</code></pre><p>改变一个张量的形状，而不改变元素的数量和元素值。其中可以通过-1来调用此自动计算出形状</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">X=x.reshape(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">X</span><br></pre></td></tr></table></figure><pre><code>tensor([[ 0,  1,  2,  3],        [ 4,  5,  6,  7],        [ 8,  9, 10, 11]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x.reshape(-<span class="number">1</span>,<span class="number">4</span>)</span><br></pre></td></tr></table></figure><pre><code>tensor([[ 0,  1,  2,  3],        [ 4,  5,  6,  7],        [ 8,  9, 10, 11]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x.reshape(<span class="number">3</span>,-<span class="number">1</span>)</span><br></pre></td></tr></table></figure><pre><code>tensor([[ 0,  1,  2,  3],        [ 4,  5,  6,  7],        [ 8,  9, 10, 11]])</code></pre><p>使用全0、全1、其他常量或者从特定分布中随机采样的数字来初始化矩阵。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.zeros((<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)),torch.ones((<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>))</span><br></pre></td></tr></table></figure><pre><code>(tensor([[[0., 0., 0., 0.],          [0., 0., 0., 0.],          [0., 0., 0., 0.]],         [[0., 0., 0., 0.],          [0., 0., 0., 0.],          [0., 0., 0., 0.]]]), tensor([[[1., 1., 1., 1.],          [1., 1., 1., 1.],          [1., 1., 1., 1.]],         [[1., 1., 1., 1.],          [1., 1., 1., 1.],          [1., 1., 1., 1.]]]))</code></pre><p>特定的概率分布中随机采样，从均值为0、标准差为1的标准高斯分布（正态分布）中随机采样</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.randn(<span class="number">3</span>,<span class="number">4</span>)</span><br></pre></td></tr></table></figure><pre><code>tensor([[-0.0805,  0.5003, -0.3091,  1.2814],        [-0.3342,  0.4061,  0.1151, -0.1609],        [-1.2401, -0.6279,  1.2042,  0.3797]])</code></pre><p>通过提供包含数值的python列表（或嵌套列表），来为所需张量中的每个元素赋予确定值。在这里，外层的列表对应于轴0，内层的列表对应于轴1</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.tensor([[<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]])</span><br></pre></td></tr></table></figure><pre><code>tensor([[2, 1, 4, 3],        [1, 2, 3, 4],        [4, 3, 2, 1]])</code></pre><p>简单的张量运算</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x=torch.tensor([<span class="number">1.0</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">8</span>])</span><br><span class="line">y=torch.tensor([<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>])</span><br><span class="line">x+y,x-y,x*y,x/y,x**y  <span class="comment">#运算符是求幂运算</span></span><br></pre></td></tr></table></figure><pre><code>(tensor([ 3.,  4.,  6., 10.]), tensor([-1.,  0.,  2.,  6.]), tensor([ 2.,  4.,  8., 16.]), tensor([0.5000, 1.0000, 2.0000, 4.0000]), tensor([ 1.,  4., 16., 64.]))</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.exp(x)<span class="comment">#按元素求幂</span></span><br></pre></td></tr></table></figure><pre><code>tensor([2.7183e+00, 7.3891e+00, 5.4598e+01, 2.9810e+03])</code></pre><p>多个张量连接，第一个 输出张量的轴0长度（6）是两个输入张量轴0 长度的总和<br>第二个输出张量的轴1长度（8）是两个输入张量轴1长度的总和</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">X=torch.arange(<span class="number">12</span>,dtype=torch.float32).reshape((<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line">Y=torch.tensor([[<span class="number">2.0</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]])</span><br><span class="line">torch.cat((X,Y),dim=<span class="number">0</span>),torch.cat((X,Y),dim=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><pre><code>(tensor([[ 0.,  1.,  2.,  3.],         [ 4.,  5.,  6.,  7.],         [ 8.,  9., 10., 11.],         [ 2.,  1.,  4.,  3.],         [ 1.,  2.,  3.,  4.],         [ 4.,  3.,  2.,  1.]]), tensor([[ 0.,  1.,  2.,  3.,  2.,  1.,  4.,  3.],         [ 4.,  5.,  6.,  7.,  1.,  2.,  3.,  4.],         [ 8.,  9., 10., 11.,  4.,  3.,  2.,  1.]]))</code></pre><p>第一个通过逻辑运算符构建二元张量<br>第二个对张量的所有元素求和，会产生一个单元素张量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X==Y,X.<span class="built_in">sum</span>(),X&lt;Y,X&gt;Y</span><br></pre></td></tr></table></figure><pre><code>(tensor([[False, False, False, False],         [False, False, False, False],         [False, False, False, False]]), tensor(298.), tensor([[False, False, False, False],         [False, False, False, False],         [False, False, False, False]]), tensor([[True, True, True, True],         [True, True, True, True],         [True, True, True, True]]))</code></pre><p>广播机制，在大多数情况下，我们将沿着数组中长度为1的轴进行广播。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a=torch.arange(<span class="number">3</span>).reshape((<span class="number">3</span>,<span class="number">1</span>))</span><br><span class="line">b=torch.arange(<span class="number">2</span>).reshape((<span class="number">1</span>,<span class="number">2</span>))</span><br><span class="line">c=torch.arange(<span class="number">8</span>).reshape((<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>))</span><br><span class="line">a,b,c,a+b,a+c</span><br></pre></td></tr></table></figure><pre><code>(tensor([[0],         [1],         [2]]), tensor([[0, 1]]), tensor([[[0, 1, 2, 3]],         [[4, 5, 6, 7]]]), tensor([[0, 1],         [1, 2],         [2, 3]]), tensor([[[0, 1, 2, 3],          [1, 2, 3, 4],          [2, 3, 4, 5]],         [[4, 5, 6, 7],          [5, 6, 7, 8],          [6, 7, 8, 9]]]))</code></pre><p>索引和切片，第一个元素的索引是0，最后一个元素的索引是-1；<br>可以指定范围以包含第一个元素和最后一个元素之前的元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X[-<span class="number">1</span>],X[<span class="number">1</span>:<span class="number">3</span>] <span class="comment">#对于轴0而言的最后一个元素</span></span><br></pre></td></tr></table></figure><pre><code>(tensor([ 8.,  9., 10., 11.]), tensor([[ 4.,  5.,  6.,  7.],         [ 8.,  9., 10., 11.]]))</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">X[<span class="number">1</span>,<span class="number">2</span>]=<span class="number">9</span> <span class="comment">#将指定元素写入矩阵</span></span><br><span class="line">X</span><br></pre></td></tr></table></figure><pre><code>tensor([[ 0.,  1.,  2.,  3.],        [ 4.,  5.,  9.,  7.],        [ 8.,  9., 10., 11.]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">X[<span class="number">0</span>:<span class="number">2</span>,:]=<span class="number">12</span> <span class="comment">#为多个元素赋予相同的值</span></span><br><span class="line">X</span><br></pre></td></tr></table></figure><pre><code>tensor([[12., 12., 12., 12.],        [12., 12., 12., 12.],        [ 8.,  9., 10., 11.]])</code></pre><p>节省内存</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">before =<span class="built_in">id</span>(Y) <span class="comment">#记录之前Y的地址</span></span><br><span class="line">Y = Y+X <span class="comment">#Y将分配到新的内存中</span></span><br><span class="line"><span class="built_in">id</span>(Y)==before <span class="comment">#验证前后Y的地址是否相同，若不同则内存地址不同</span></span><br></pre></td></tr></table></figure><pre><code>False</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#但在日常使用中，我们更希望其执行原地操作</span></span><br><span class="line">Z=torch.zeros_like(Y)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;id(Z):&#x27;</span>,<span class="built_in">id</span>(Z))</span><br><span class="line">Z[:]=X+Y</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;id(Z):&#x27;</span>,<span class="built_in">id</span>(Z))</span><br></pre></td></tr></table></figure><pre><code>id(Z): 140064498968624id(Z): 140064498968624</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#也可以使用X+=Y来减少操作的内存开销</span></span><br><span class="line">before =<span class="built_in">id</span>(X)</span><br><span class="line">X+=Y</span><br><span class="line"><span class="built_in">id</span>(X)==before</span><br></pre></td></tr></table></figure><pre><code>True</code></pre><p>转换为其他python对象<br>将深度学习框架定义的张量转换为Numpy张量（ndarry）很容易，反之也同样容易。torch张量和numpy数组将共享它们的底层内存<br>就地操作更改一个张量也会同时更改另一个张量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A=X.numpy()</span><br><span class="line">B = torch.tensor(A)</span><br><span class="line"><span class="built_in">type</span>(A),<span class="built_in">type</span>(B)</span><br></pre></td></tr></table></figure><pre><code>(numpy.ndarray, torch.Tensor)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = torch.tensor([<span class="number">3.5</span>]) <span class="comment">#要将大小为1的张量转换为Python标量，我们可以调用item函数或Python的内置函数</span></span><br><span class="line">a,a.item(),<span class="built_in">float</span>(a),<span class="built_in">int</span>(a)</span><br></pre></td></tr></table></figure><pre><code>(tensor([3.5000]), 3.5, 3.5, 3)</code></pre>]]></content:encoded>
      
      
      <category domain="https://luckytoadventure.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/">深度学习</category>
      
      
      <category domain="https://luckytoadventure.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/">深度学习</category>
      
      
      <comments>https://luckytoadventure.com/2023/12/24/1st_Get_started/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>C++入门</title>
      <link>https://luckytoadventure.com/2023/12/24/C++%E5%85%A5%E9%97%A8/</link>
      <guid>https://luckytoadventure.com/2023/12/24/C++%E5%85%A5%E9%97%A8/</guid>
      <pubDate>Sun, 24 Dec 2023 04:47:02 GMT</pubDate>
      
      <description>&lt;p&gt;本文介绍了C++的基本知识包括C++初识、数据类型、运算符、程序流程结构、数组、函数、指针、结构体。最后总结知识点，编写了一个简单的通讯录管理系统。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>本文介绍了C++的基本知识包括C++初识、数据类型、运算符、程序流程结构、数组、函数、指针、结构体。最后总结知识点，编写了一个简单的通讯录管理系统。</p> <span id="more"></span><p>参考：黑马程序员课程</p><h1 id="C-入门"><a href="#C-入门" class="headerlink" title="C++入门"></a>C++入门</h1><h2 id="1C-初识"><a href="#1C-初识" class="headerlink" title="1C++初识"></a>1C++初识</h2><h3 id="1-1第一个C-程序"><a href="#1-1第一个C-程序" class="headerlink" title="1.1第一个C++程序"></a>1.1第一个C++程序</h3><p>书写hello world!</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;hello world&quot; &lt;&lt; endl;</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2注释"><a href="#1-2注释" class="headerlink" title="1.2注释"></a>1.2注释</h3><p><code>//单行注释</code></p><p><code>/**/多行注释</code></p><h3 id="1-3变量"><a href="#1-3变量" class="headerlink" title="1.3变量"></a>1.3变量</h3><p>变量存在的意义：方便我们管理内存空间。</p><p>变量创建的语法：数据类型 变量名 = 变量初始值；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int a = 10;</span><br><span class="line">cout &lt;&lt; &quot;a=&quot; &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-常量"><a href="#1-4-常量" class="headerlink" title="1.4 常量"></a>1.4 常量</h3><p>作用：用于记录程序中不可更改的数据</p><p>c++定义常量的两种方式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//常量的定义方式</span><br><span class="line">//1.#define宏常量</span><br><span class="line"></span><br><span class="line">//2.const修饰的变量</span><br><span class="line"></span><br><span class="line">//1.#define 宏常量</span><br><span class="line">#define Day 7</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;一周总共有：&quot; &lt;&lt; Day &lt;&lt; &quot;天&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">//const 修饰的变量</span><br><span class="line">const int month = 12;</span><br><span class="line">cout &lt;&lt; &quot;一年总共有：&quot; &lt;&lt; month &lt;&lt; &quot;月&quot; &lt;&lt; endl;</span><br><span class="line">//month = 24 报错，常量是不可修改的</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-5-标识符命名规则"><a href="#1-5-标识符命名规则" class="headerlink" title="1.5 标识符命名规则"></a>1.5 标识符命名规则</h3><p>作用：C++规定给标识符（变量、常量）命名时，有一套自己的规则</p><ul><li>标识符不能是关键字</li><li>标识符只能由字母、数字、下划线组成</li><li>第一个字符必须为字母或下划线</li><li>标识符中字母区分大小写</li></ul><h2 id="2-数据类型"><a href="#2-数据类型" class="headerlink" title="2 数据类型"></a>2 数据类型</h2><h3 id="2-1-数据类型"><a href="#2-1-数据类型" class="headerlink" title="2.1 数据类型"></a>2.1 数据类型</h3><p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20231210153935095.png" alt="image-20231210153935095"></p><h3 id="2-2-sizeof关键字"><a href="#2-2-sizeof关键字" class="headerlink" title="2.2 sizeof关键字"></a>2.2 sizeof关键字</h3><p>可以利用sizeof求出数据类型的占用内存的大小。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//sizeof(数据类型/变量)</span><br><span class="line"></span><br><span class="line">//整型大小比较</span><br><span class="line"></span><br><span class="line">//short&lt;int&lt;=long&lt;=long long</span><br></pre></td></tr></table></figure><h3 id="2-3-实型（浮点型）"><a href="#2-3-实型（浮点型）" class="headerlink" title="2.3 实型（浮点型）"></a>2.3 实型（浮点型）</h3><p>作用：用于表示小数</p><p>1.单精度 float</p><p>2.双精度 double</p><p><img src="..\C++入门\image-20231210154909225.png" alt="image-20231210154909225"></p><p>默认double，float 声明时若想为float则需加f。</p><p>//默认情况下，输出一个小数，会显示6位有效数字。</p><p>//科学计数法</p><p><code>float f2 = 3e2; //3*10^2;</code></p><h3 id="2-4-字符型"><a href="#2-4-字符型" class="headerlink" title="2.4 字符型"></a>2.4 字符型</h3><p>作用：字符型变量用于显示单个字符</p><p>语法：<code>char ch = &#39;a&#39;;</code></p><ul><li>[ ] 注意1：子啊显示字符型变量时，用单引号将字符括起来，不要用双引号。</li><li><p>[ ] 注意2：单引号内只能有一个字符，不可以是字符串</p></li><li><p>C和C++中字符型变量只占用1个字节</p></li><li>字符型变量并不是把字符本身放到内存中存储，而是将对应的ASCII编码放入到存储单元</li></ul><h3 id="2-5-转义字符"><a href="#2-5-转义字符" class="headerlink" title="2.5 转义字符"></a>2.5 转义字符</h3><p>“  \ \ “代表一个反斜杠”\“</p><h3 id="2-6-字符串型"><a href="#2-6-字符串型" class="headerlink" title="2.6 字符串型"></a>2.6 字符串型</h3><p>作用：用于表示一串字符</p><p>1.C风格字符串：<code>char 变量名[] = ”字符串“</code></p><p>2.C++风格字符串： <code>string 变量名 = ”字符串值“</code></p><p>C++风格字符串需加入头文件，<code>#include&lt;string&gt;</code></p><h3 id="2-7-布尔类型"><a href="#2-7-布尔类型" class="headerlink" title="2.7 布尔类型"></a>2.7 布尔类型</h3><p>作用：布尔数据类型代表真或假的值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//创建bool数据类型</span><br><span class="line"></span><br><span class="line">bool flag = true; //代表真 1</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; flag &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">//2.查看bool类型占用的空间</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; sizeof(flag) &lt;&lt; endl; //等于1</span><br></pre></td></tr></table></figure><h3 id="2-8数据的输入"><a href="#2-8数据的输入" class="headerlink" title="2.8数据的输入"></a>2.8数据的输入</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//1、整型</span><br><span class="line"></span><br><span class="line">int a = 0;</span><br><span class="line"></span><br><span class="line">cin &gt;&gt; a;</span><br><span class="line"></span><br><span class="line">// 2.浮点型</span><br><span class="line"></span><br><span class="line">float f = 3.14f;</span><br><span class="line"></span><br><span class="line">cin &gt;&gt; f;</span><br><span class="line"></span><br><span class="line">// 字符型</span><br><span class="line"></span><br><span class="line">char ch = &#x27;a&#x27;;</span><br><span class="line"></span><br><span class="line">cin &gt;&gt; ch;</span><br><span class="line"></span><br><span class="line">//字符串型</span><br><span class="line"></span><br><span class="line">string str = &quot;hello&quot;;</span><br><span class="line"></span><br><span class="line">cin &gt;&gt; str;</span><br><span class="line"></span><br><span class="line">//布尔数据</span><br><span class="line"></span><br><span class="line">bool flag = false;</span><br><span class="line"></span><br><span class="line">cin &gt;&gt; flag;//非0的值都为真</span><br></pre></td></tr></table></figure><h2 id="3-运算符"><a href="#3-运算符" class="headerlink" title="3 运算符"></a>3 运算符</h2><h3 id="3-1-算术运算符"><a href="#3-1-算术运算符" class="headerlink" title="3.1 算术运算符"></a>3.1 算术运算符</h3><p><img src="..\C++入门\image-20231210162129314.png" alt="image-20231210162129314"></p><p><img src="..\C++入门\image-20231210162238426.png" alt="image-20231210162238426"></p><p>两个整数相除，结果依然是整数，将小数部分去除，向下取整。</p><p>在除法运算中，除数不能为0。</p><p>两个小数是不可以做取模运算的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//前置递增</span><br><span class="line"></span><br><span class="line">int a = 10;</span><br><span class="line"></span><br><span class="line">++a;</span><br><span class="line"></span><br><span class="line">//后置递增</span><br><span class="line"></span><br><span class="line">int b = 10;</span><br><span class="line"></span><br><span class="line">b++;</span><br><span class="line"></span><br><span class="line">//前置和后置的区别</span><br><span class="line"></span><br><span class="line">//前置递增，先让变量+1 然后进行表达式运算</span><br><span class="line"></span><br><span class="line">//后置运算 先进行表达式运算 后让变量+1</span><br></pre></td></tr></table></figure><h3 id="3-2-赋值运算符"><a href="#3-2-赋值运算符" class="headerlink" title="3.2 赋值运算符"></a>3.2 赋值运算符</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//=</span><br><span class="line"></span><br><span class="line">int a = 10;</span><br><span class="line"></span><br><span class="line">a = 100;</span><br><span class="line"></span><br><span class="line">// +=</span><br><span class="line"></span><br><span class="line">a = 10;</span><br><span class="line"></span><br><span class="line">a += 2; //a = 10+2 = 12</span><br><span class="line"></span><br><span class="line">// -=</span><br><span class="line"></span><br><span class="line">a = 10;</span><br><span class="line"></span><br><span class="line">a - = 2;</span><br><span class="line"></span><br><span class="line">//*=</span><br><span class="line"></span><br><span class="line">a = 10;</span><br><span class="line"></span><br><span class="line">a *= 2; //a = a*2</span><br><span class="line"></span><br><span class="line">// %=</span><br><span class="line"></span><br><span class="line">a = 10;</span><br><span class="line"></span><br><span class="line">a %= 2; //a = a % 2;</span><br></pre></td></tr></table></figure><h3 id="3-3-比较运算符"><a href="#3-3-比较运算符" class="headerlink" title="3.3 比较运算符"></a>3.3 比较运算符</h3><p><img src="..\C++入门\image-20231210164016670.png" alt="image-20231210164016670"></p><h3 id="3-4-逻辑运算符"><a href="#3-4-逻辑运算符" class="headerlink" title="3.4 逻辑运算符"></a>3.4 逻辑运算符</h3><p><img src="..\C++入门\image-20231210164136929.png" alt="image-20231210164136929"></p><p><code>！！a//对a取两次反</code></p><h2 id="4-程序流程结构"><a href="#4-程序流程结构" class="headerlink" title="4 程序流程结构"></a>4 程序流程结构</h2><p><img src="..\C++入门\image-20231210164517155.png" alt="image-20231210164517155"></p><h3 id="4-1-选择结构"><a href="#4-1-选择结构" class="headerlink" title="4.1 选择结构"></a>4.1 选择结构</h3><h4 id="4-1-1-if语句"><a href="#4-1-1-if语句" class="headerlink" title="4.1.1 if语句"></a>4.1.1 if语句</h4><p>1.单行格式if语句</p><p><img src="..\C++入门\image-20231210164724163.png" alt="image-20231210164724163"></p><p><code>if （score &gt; 600); //加分号表示结束循环，此时为一个空循环</code></p><p>2.多行格式if语句</p><p><img src="..\C++入门\image-20231210165617463.png" alt="image-20231210165617463"></p><p>3.多条件的if语句</p><p><img src="..\C++入门\image-20231210165727352.png" alt="image-20231210165727352"></p><p>4.嵌套if语句</p><h4 id="4-1-2-三目运算符"><a href="#4-1-2-三目运算符" class="headerlink" title="4.1.2 三目运算符"></a>4.1.2 三目运算符</h4><p>作用：通过三目运算符实现简单的判断</p><p>语法：<code>表达式1 ？ 表达式2 ： 表达式3</code></p><p>解释：</p><p>如果表达式1的值为真，执行表达式2，并返回表达式2的结果</p><p>如果表达式1的值为假，执行表达式3，并返回表达式3的结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//在C++中三目运算符返回的是变量，可以继续赋值</span><br><span class="line"></span><br><span class="line">(a &lt; b ? a : b) = 100;</span><br></pre></td></tr></table></figure><h4 id="4-1-3-switch-语句"><a href="#4-1-3-switch-语句" class="headerlink" title="4.1.3 switch 语句"></a>4.1.3 switch 语句</h4><p>作用：执行多条件分支语句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">switch(表达式)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">case 结果1 : 执行语句;break；</span><br><span class="line"></span><br><span class="line">case 结果2 : 执行语句;break;</span><br><span class="line"></span><br><span class="line">default : 执行语句;break;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//if 和 switch的区别</span><br><span class="line">//switch 缺点，判断时候只能是整型或者字符型，不可以是一个区间</span><br><span class="line">//switch 优点，结构清晰，执行效率高</span><br></pre></td></tr></table></figure><h3 id="4-2-循环结构"><a href="#4-2-循环结构" class="headerlink" title="4.2 循环结构"></a>4.2 循环结构</h3><h4 id="4-2-1-while-循环语句"><a href="#4-2-1-while-循环语句" class="headerlink" title="4.2.1 while 循环语句"></a>4.2.1 while 循环语句</h4><p><img src="..\C++入门\image-20231210171119445.png" alt="image-20231210171119445"></p><blockquote><p>注意：在执行循环语句时，程序必须提供跳出循环的出口，否则出现死循环。</p></blockquote><p>随机数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rand()%100 //生成0~99的随机数</span><br><span class="line"></span><br><span class="line">rand()%100 + 1//生成1~100的随机数</span><br></pre></td></tr></table></figure><h4 id="4-2-2-do…while循环语句"><a href="#4-2-2-do…while循环语句" class="headerlink" title="4.2.2 do…while循环语句"></a>4.2.2 do…while循环语句</h4><p>注意：与while的区别在于do…while会先执行一次循环语句，再判断循环条件</p><p><img src="..\C++入门\image-20231210171629480.png" alt="image-20231210171629480"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//在屏幕中输出0到9这10个数字</span><br><span class="line"></span><br><span class="line">int num = 0;</span><br><span class="line"></span><br><span class="line">do</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">​cout  &lt;&lt; num &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">​num++; </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">while (num &lt; 10);</span><br></pre></td></tr></table></figure><p>水仙花数</p><p>案例描述：水仙花数是指一个3位数，它的每个位上的数字的3次幂之和等于它本身</p><p>例如：1^3 + 5^3 + 3^3 = 153</p><p>请利用do……while语句，求出所有3位数中的水仙花数</p><p>1.将所有的三位数进行输出 （100~999）</p><p>2.在所有三位数中找到水仙花数</p><p>​    水仙花数</p><p>​    获取个位     153%10 = 3</p><p>​    获取十位     153/10 = 15    15%10 = 5</p><p>​    获取百位      153/100 = 1</p><p>​    判断 个位^3 + 十位^3 + 百位^3 = 本身</p><h4 id="4-2-3-for循环语句"><a href="#4-2-3-for循环语句" class="headerlink" title="4.2.3 for循环语句"></a>4.2.3 for循环语句</h4><blockquote><p>注意：for循环中的表达式，要用分号进行分隔</p><p>总结：while,do……while，for都是开发中常用的循环语句，for循环结构比较清晰，比较常用</p></blockquote><h4 id="4-2-4-嵌套循环"><a href="#4-2-4-嵌套循环" class="headerlink" title="4.2.4 嵌套循环"></a>4.2.4 嵌套循环</h4><p>乘法口诀表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for (int i=1; i&lt;=9 ; i++)&#123;</span><br><span class="line">for (int j=1;j&lt;=i;j++)&#123;</span><br><span class="line">cout &lt;&lt; j &lt;&lt; &quot;*&quot; &lt;&lt; i &lt;&lt; &quot;=&quot; &lt;&lt; i*j &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-跳转语句"><a href="#4-3-跳转语句" class="headerlink" title="4.3 跳转语句"></a>4.3 跳转语句</h3><h4 id="4-3-1-break语句"><a href="#4-3-1-break语句" class="headerlink" title="4.3.1 break语句"></a>4.3.1 break语句</h4><p><img src="..\C++入门\image-20231210175435905.png" alt="image-20231210175435905"></p><h4 id="4-3-2-continue-语句"><a href="#4-3-2-continue-语句" class="headerlink" title="4.3.2 continue 语句"></a>4.3.2 continue 语句</h4><p>作用：在循环语句中，跳过本次循环中余下尚未执行的语句，继续执行下一次循环</p><h4 id="4-3-3-goto语句"><a href="#4-3-3-goto语句" class="headerlink" title="4.3.3 goto语句"></a>4.3.3 goto语句</h4><p>作用：可以无条件跳转语句</p><p>语法：<code>goto 标记；</code></p><p>解释：如果标记的名称存在，执行到goto语句时，会跳转到标记位置</p><h2 id="5-数组"><a href="#5-数组" class="headerlink" title="5 数组"></a>5 数组</h2><p>一维数组</p><p><img src="..\C++入门\image-20231210180303431.png" alt="image-20231210180303431"></p><p>使用第二种方式时，初始化数据，没有填完，会用0填充。</p><blockquote><p>可以通过数组名查看数组首地址</p><p>数组中元素的个数：sizeof(arr)/sizeof(arr[0])</p></blockquote><p>数组中第一个元素的地址：(int) &amp;arr[0]</p><p>元素逆置</p><p>1.创建数组</p><p>2.实现逆置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">//实现逆置</span><br><span class="line">//1.记录起始下标位置</span><br><span class="line">//2.记录结束下表位置</span><br><span class="line">//3.起始下标与结束下标的元素互换</span><br><span class="line">//4.起始位置++，结束位置--</span><br><span class="line">//5.循环执行</span><br><span class="line">int arr[] = &#123; 2,9,8,7,6 &#125;;</span><br><span class="line">int start = 0;</span><br><span class="line">int end = sizeof(arr) / sizeof(arr[0])-1;</span><br><span class="line">do</span><br><span class="line">&#123;</span><br><span class="line">int temp = arr[start];</span><br><span class="line">arr[start] = arr[end];</span><br><span class="line">arr[end] = temp;//实现互换位置</span><br><span class="line">start++;</span><br><span class="line">end--;</span><br><span class="line">&#125; while (start &lt; end);</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>冒泡排序</p><p>1.比较相邻元素，如果第一个比第二个大，就交换他们两个</p><p>2.对每一对相邻元素做同样的工作，执行完毕后，找到第一个最大值</p><p>3.重复以上的步骤，每次比较次数-1，直到不需要比较</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int arr[] = &#123; 4,2,8,0,5,7,1,3,9 &#125;;</span><br><span class="line">int end = sizeof(arr) / sizeof(arr[0]);</span><br><span class="line">for (int i = 0; i &lt; end - 1; i++)</span><br><span class="line">&#123;</span><br><span class="line">for (int j = 0; j &lt; end - i - 1; j++)</span><br><span class="line">&#123;</span><br><span class="line">if (arr[j] &lt; arr[j + 1])</span><br><span class="line">&#123;</span><br><span class="line">int temp = arr[j];</span><br><span class="line">arr[j] = arr[j + 1];</span><br><span class="line">arr[j + 1] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for (int i = 0; i &lt; end; i++) &#123;</span><br><span class="line">cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二维数组</p><p>二维数组的定义方式：</p><p><img src="..\C++入门\image-20231212155522641.png" alt="image-20231212155522641"></p><p>二维数组组名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int arr[2][3] =</span><br><span class="line">&#123;</span><br><span class="line">&#123;1,2,3&#125;,</span><br><span class="line">&#123;4,5,6&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;二维数组占用内存空间为：&quot; &lt;&lt; sizeof(arr) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;二维数组第一行占用内存：&quot; &lt;&lt; sizeof(arr[0]) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;二维数组第一个元素占用内存为：&quot; &lt;&lt; sizeof(arr[0][0]) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;二维数组的行数：&quot; &lt;&lt; sizeof(arr) / sizeof(arr[0]) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;二维数组的列数：&quot; &lt;&lt; sizeof(arr[0]) / sizeof(arr[0][0]) &lt;&lt; endl;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="6-函数"><a href="#6-函数" class="headerlink" title="6 函数"></a>6 函数</h2><h3 id="6-1-概述"><a href="#6-1-概述" class="headerlink" title="6.1 概述"></a>6.1 概述</h3><p>作用：将一段经常使用的代码封装起来，减少重复代码</p><p>一个较大的程序，一般分为若干个程序块，每个模块实现特定的功能</p><h3 id="6-2-函数的定义"><a href="#6-2-函数的定义" class="headerlink" title="6.2 函数的定义"></a>6.2 函数的定义</h3><p>函数的定义一般主要有5个步骤：</p><p>1.返回值类型</p><p>2.函数名</p><p>3.参数biaolie</p><p>4.函数体语句</p><p>5.return 表达式</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">返回值类型 函数名 （参数列表）</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">函数体语句</span><br><span class="line">return 表达式</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-3-函数的调用"><a href="#6-3-函数的调用" class="headerlink" title="6.3 函数的调用"></a>6.3 函数的调用</h3><blockquote><p>总结：函数定义里小括号称为形参，函数调用时传入的参数称为实参。</p></blockquote><h3 id="6-4-值传递"><a href="#6-4-值传递" class="headerlink" title="6.4 值传递"></a>6.4 值传递</h3><p>当我们做值传递的时候，函数的形参发生改变，并不会影响实参</p><h3 id="6-5-函数的常见样式"><a href="#6-5-函数的常见样式" class="headerlink" title="6.5 函数的常见样式"></a>6.5 函数的常见样式</h3><p>常见的函数样式有4种</p><p>1.无参无返</p><p>2.有参无返</p><p>3.无参有返</p><p>4.有参有返</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//函数常见样式</span><br><span class="line">//无参无返</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;this is test01&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//有参无返</span><br><span class="line">void test02(int a)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;this is test02&quot; &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//无参有返</span><br><span class="line">int test03()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;this is test03&quot; &lt;&lt; endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//有参有返</span><br><span class="line">int test04(int b)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;this is test04&quot; &lt;&lt; endl;</span><br><span class="line">return b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-6-函数的声明"><a href="#6-6-函数的声明" class="headerlink" title="6.6 函数的声明"></a>6.6 函数的声明</h3><p>作用：为了告诉编译器这个函数存在并链接到这个函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//函数声明</span><br><span class="line">int max(int a,int b);</span><br><span class="line"></span><br><span class="line">int max(int a,int b)</span><br><span class="line">&#123;</span><br><span class="line">return a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int a = 10;</span><br><span class="line">int b = 20;</span><br><span class="line">cout &lt;&lt; max(a,b) &lt;&lt; endl;</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-7函数的分文件编写"><a href="#6-7函数的分文件编写" class="headerlink" title="6.7函数的分文件编写"></a>6.7函数的分文件编写</h3><p>作用：让代码结构更加清晰</p><p>函数分文件编写一般有4个步骤</p><p>1.创建后缀名为.h的头文件</p><p>2.创建后缀名为.cpp的源文件</p><p>3.在头文件中写函数的声明</p><p>4.在源文件中写函数的定义</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//swap.h</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void swap(int a,int b);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//swap.cpp</span><br><span class="line">#include &quot;swap.h&quot;</span><br><span class="line">void swap(int a,int b)</span><br><span class="line">&#123;</span><br><span class="line">int temp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line">cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//函数的分文件编写</span><br><span class="line">//实现两个数字进行交换的函数</span><br><span class="line">//函数的声明</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include &quot;swap.h&quot;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int a = 10;</span><br><span class="line">int b = 20;</span><br><span class="line">swap(a,b);</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-指针"><a href="#7-指针" class="headerlink" title="7 指针"></a>7 指针</h2><h3 id="7-1指针的概念"><a href="#7-1指针的概念" class="headerlink" title="7.1指针的概念"></a>7.1指针的概念</h3><p>指针的作用：可以通过指针间接访问内存</p><ul><li>内存编号是从0开始记录的，一般用十六进制数字表示</li><li>可以利用指针变量保存地址</li></ul><h3 id="7-2指针变量的定义和使用"><a href="#7-2指针变量的定义和使用" class="headerlink" title="7.2指针变量的定义和使用"></a>7.2指针变量的定义和使用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//定义指针</span><br><span class="line">int a = 10;</span><br><span class="line">//指针定义的语法：数据类型 * 指针变量名</span><br><span class="line">int *p;</span><br><span class="line">//让指针记录变量a的地址</span><br><span class="line">p = &amp;a;</span><br><span class="line">cout &lt;&lt; &quot;a的地址:&quot; &lt;&lt; &amp;a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;指针p为:&quot; &lt;&lt; p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">//2.可以使用解引用的方式调用指针</span><br><span class="line">//指针前加 * 表示解引用，找到指针指向的内存中的数据</span><br><span class="line">*p = 1000;</span><br><span class="line">cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;*p = &quot; &lt;&lt; *p &lt;&lt; endl;</span><br></pre></td></tr></table></figure><h3 id="7-3指针所占的内存空间"><a href="#7-3指针所占的内存空间" class="headerlink" title="7.3指针所占的内存空间"></a>7.3指针所占的内存空间</h3><p>根据操作系统的不同，指针所占内存空间不同，在32位操作系统下，所占为4个字节，在64位操作系统下，所占为8个字节（无论是什么数据类型）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//指针所占的内存空间大小</span><br><span class="line">int a = 10;</span><br><span class="line">int *p = &amp;a;</span><br><span class="line">cout &lt;&lt; &quot;sizeof (int *) = &quot; &lt;&lt; sizeof(p) &lt;&lt; endl;</span><br></pre></td></tr></table></figure><h3 id="7-4-空指针和野指针"><a href="#7-4-空指针和野指针" class="headerlink" title="7.4 空指针和野指针"></a>7.4 空指针和野指针</h3><p>空指针：指针变量指向内存中编号为0的空间</p><p>用途：初始化指针变量</p><p>注意：空指针指向的内存是不可以访问的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//空指针用于给指针变量用于初始化</span><br><span class="line">int *p = NULL; //地址编号指向0</span><br><span class="line">//空指针是不可以进行访问的</span><br><span class="line">//0~255之间的内存编号是系统占用的，不可以直接访问</span><br><span class="line">*p = 100;//运行出错</span><br></pre></td></tr></table></figure><p>野指针：指针变量指向非法空间</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//野指针</span><br><span class="line">int *p = (int *)0x1100;//转成指针类型</span><br><span class="line">//读取访问权限冲突</span><br><span class="line">cout &lt;&lt; *p &lt;&lt; endl;</span><br></pre></td></tr></table></figure><blockquote><p>总结：空指针和野指针都不是我们申请的空间，因此不要访问</p></blockquote><h3 id="7-5-const修饰指针"><a href="#7-5-const修饰指针" class="headerlink" title="7.5 const修饰指针"></a>7.5 const修饰指针</h3><p>const 修饰指针有三种情况：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//1.const 修饰指针——常量指针</span><br><span class="line">const int *p = &amp;a;</span><br><span class="line"></span><br><span class="line">//常量指针</span><br><span class="line"></span><br><span class="line">//特点：指针的指向可以修改，但是指针指向的值不可以改。</span><br><span class="line"></span><br><span class="line">*p = 20;//错误，指针指向的值不可以改</span><br><span class="line"></span><br><span class="line">p = &amp;b;//正确，指向可以更改</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//const 修饰常量</span><br><span class="line">int * const p = &amp;a;//指针常量，int *const p是作用在*，即指针指向不可以更改</span><br><span class="line"></span><br><span class="line">//特点：指针的指向不可以更改，指针的值可以更改</span><br><span class="line"></span><br><span class="line">*p = 20;//正确，指向的值可以更改</span><br><span class="line">p = &amp;b;//错误，指针的指向不可以更改</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//3.const 既修饰指针，又修饰常量</span><br><span class="line">const int * const p = &amp;a;</span><br><span class="line">//特点：指针的指向和指针指向的值都不可以改</span><br><span class="line">*p = 20;//错误</span><br><span class="line">p = &amp;b;//错误</span><br></pre></td></tr></table></figure><h3 id="7-6指针和数组"><a href="#7-6指针和数组" class="headerlink" title="7.6指针和数组"></a>7.6指针和数组</h3><p>作用：利用指针访问数组中元素</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//指针和数组</span><br><span class="line">//利用指针访问数组中的元素</span><br><span class="line">int arr[10] = &#123;1,2,3,4,5,6,7,8,9&#125;;</span><br><span class="line">cout &lt;&lt; &quot;第一个元素：&quot; &lt;&lt; arr[0] &lt;&lt; endl;</span><br><span class="line">int *p = arr;//arr就是数组的首地址</span><br><span class="line">cout &lt;&lt; &quot;利用指针访问第一个元素：&quot; &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">p++;//让指针向后偏移四个字节</span><br><span class="line">cout &lt;&lt; &quot;利用指针访问第二个元素：&quot; &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;利用指针遍历数组&quot; &lt;&lt; endl;</span><br><span class="line">int *p2 = arr;</span><br><span class="line">for (int i=0; i&lt;10; i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *p2 &lt;&lt; endl;</span><br><span class="line">p2++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-7指针和函数"><a href="#7-7指针和函数" class="headerlink" title="7.7指针和函数"></a>7.7指针和函数</h3><p>作用：利用指针作函数参数，可以修改变量值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//指针和函数</span><br><span class="line">//1.值传递</span><br><span class="line">void swap01(int a,int b)</span><br><span class="line">&#123;</span><br><span class="line">int temp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int a = 20;</span><br><span class="line">int b = 10;</span><br><span class="line">swap01(a,b);</span><br><span class="line">&#125;</span><br><span class="line">//2.地址传递</span><br><span class="line">void swap02(int *p1,int *p2)</span><br><span class="line">&#123;</span><br><span class="line">int temp = *p1;</span><br><span class="line">*p1 = *p2;</span><br><span class="line">*p2 = temp;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int a = 20;</span><br><span class="line">int b = 10;</span><br><span class="line">swap02(&amp;a,&amp;b);//把地址传进去</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-8-指针、数组、函数"><a href="#7-8-指针、数组、函数" class="headerlink" title="7.8 指针、数组、函数"></a>7.8 指针、数组、函数</h3><p>案例描述： 封装一个函数，利用冒泡排序，实现对整型数组的升序排序</p><p>例如数组：int arr[10] = {4,3,6,9,1,2,10,8,7,5}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">//冒泡排序函数</span><br><span class="line">void bubbleSort(int *arr,int len)</span><br><span class="line">&#123;</span><br><span class="line">for (int i =0;i &lt; len -1;i++)</span><br><span class="line">&#123;</span><br><span class="line">for (int j = 0;j &lt; len-1-i;j++)</span><br><span class="line">&#123;</span><br><span class="line">if (arr[j] &gt; arr[j+1])</span><br><span class="line">&#123;</span><br><span class="line">int temp = arr[j];</span><br><span class="line">arr[j] = arr[j+1];</span><br><span class="line">arr[j+1] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">void printArray(int *arr,int len)</span><br><span class="line">&#123;</span><br><span class="line">for (int i=0;i&lt;len;i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">//创建数组</span><br><span class="line">int arr[10] = &#123;4,3,6,9,1,2,10,8,7,5&#125;;</span><br><span class="line">int len = sizeof(arr) / sizeof(arr[0]);</span><br><span class="line">bubbleSort(arr,len);</span><br><span class="line">printArray(arr,len);</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-结构体"><a href="#8-结构体" class="headerlink" title="8 结构体"></a>8 结构体</h2><h3 id="8-1结构体的基本概念"><a href="#8-1结构体的基本概念" class="headerlink" title="8.1结构体的基本概念"></a>8.1结构体的基本概念</h3><p>结构体属于用户自定义的数据类型，允许用户存储不同的数据类型</p><h3 id="8-2-结构体定义和使用"><a href="#8-2-结构体定义和使用" class="headerlink" title="8.2 结构体定义和使用"></a>8.2 结构体定义和使用</h3><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct 结构体名 &#123;结构体成员列表&#125;</span><br></pre></td></tr></table></figure><p>通过结构体构建变量的方式有三种：</p><ul><li>struct 结构体名 变量名</li><li>struct 结构体名 变量名 = {成员1值，成员2值}</li><li>定义结构体时顺便创建变量</li></ul><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//1.创建学生类型：学生包括（姓名，年龄，分数）</span><br><span class="line">//自定义数据类型</span><br><span class="line">struct Student</span><br><span class="line">&#123;</span><br><span class="line">//成员列表</span><br><span class="line">string name;//姓名</span><br><span class="line">int age;//年龄</span><br><span class="line">int score;//分数</span><br><span class="line">&#125;s3;</span><br><span class="line">//通过学生类型创建具体学生</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">//第一种方式</span><br><span class="line">struct Student s1;</span><br><span class="line">s1.name = &quot;张三&quot;;</span><br><span class="line">s1.age = 18;</span><br><span class="line">s1.score = 100;</span><br><span class="line"></span><br><span class="line">//第二种方式</span><br><span class="line">struct Student s2 = &#123;&quot;李四&quot;,19,100&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//创建结构体时，就创建变量</span><br><span class="line">s3.name = &quot;w&quot;;</span><br><span class="line">s3.age = 18;</span><br><span class="line">s3.score = 99;</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结1：定义结构体时的关键字是struct，不可省略</p><p>总结2：创建结构体变量时，关键字struct可以省略</p><p>总结3：结构体变量利用操作符”.”访问成员</p></blockquote><h3 id="8-3结构体数组"><a href="#8-3结构体数组" class="headerlink" title="8.3结构体数组"></a>8.3结构体数组</h3><p>作用：将自定义的结构体放入到数组中方便维护</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">struct Student</span><br><span class="line">&#123;</span><br><span class="line">//成员列表</span><br><span class="line">string name;//姓名</span><br><span class="line">int age;//年龄</span><br><span class="line">int score;//分数</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">struct Student stuArray[3] = </span><br><span class="line">&#123;</span><br><span class="line">&#123;&quot;张三&quot;,18,100&#125;,</span><br><span class="line">&#123;&quot;李四&quot;,28,99&#125;,</span><br><span class="line">&#123;&quot;王五&quot;,38,66&#125;</span><br><span class="line">&#125;;</span><br><span class="line">//给结构体数组中的元素赋值</span><br><span class="line">stuArray[2].name = &quot;赵六&quot;;</span><br><span class="line">stuArray[2].age = 80;</span><br><span class="line">stuArray[2].score = 100;</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-4结构体指针"><a href="#8-4结构体指针" class="headerlink" title="8.4结构体指针"></a>8.4结构体指针</h3><p>作用：通过指针访问结构体的成员</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">struct student</span><br><span class="line">&#123;</span><br><span class="line">//成员列表</span><br><span class="line">string name;//姓名</span><br><span class="line">int age;//年龄</span><br><span class="line">int score;//分数</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">//创建学生的结构体变量</span><br><span class="line">struct student s = &#123;&quot;张三&quot;,18,100&#125;</span><br><span class="line">//通过指针指向结构体变量</span><br><span class="line">struct student int * p = &amp;s;//struct可以省略，以上皆是如此</span><br><span class="line">//通过指针访问结构体变量中的数据</span><br><span class="line">cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; p-&gt;name &lt;&lt; endl;</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-5结构体嵌套结构体"><a href="#8-5结构体嵌套结构体" class="headerlink" title="8.5结构体嵌套结构体"></a>8.5结构体嵌套结构体</h3><p>作用：结构体中的成员可以是另一个结构体</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//学生结构体定义</span><br><span class="line">struct student</span><br><span class="line">&#123;</span><br><span class="line">//成员列表</span><br><span class="line">string name;//姓名</span><br><span class="line">int age;//年龄</span><br><span class="line">int score;//分数</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//教师结构体定义</span><br><span class="line">struct teacher </span><br><span class="line">&#123;</span><br><span class="line">int id;</span><br><span class="line">string name;</span><br><span class="line">int age;</span><br><span class="line">struct student stu;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">teacher t;</span><br><span class="line">t.id = 10000;</span><br><span class="line">t.name = &quot;老王&quot;;</span><br><span class="line">t.age = 50;</span><br><span class="line">t.stu.name = &quot;小王&quot;;</span><br><span class="line">t.stu.age = 20;</span><br><span class="line">t.stu.score = 100;</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-6结构体作函数参数"><a href="#8-6结构体作函数参数" class="headerlink" title="8.6结构体作函数参数"></a>8.6结构体作函数参数</h3><p>作用：将结构体作为参数向函数传递</p><p>传递方式有两种：</p><ul><li>值传递——形参变实参不变</li><li>地址传递——形参变实参也变</li></ul><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//学生结构体定义</span><br><span class="line">struct student</span><br><span class="line">&#123;</span><br><span class="line">//成员列表</span><br><span class="line">string name;//姓名</span><br><span class="line">int age;//年龄</span><br><span class="line">int score;//分数</span><br><span class="line">&#125;;</span><br><span class="line">void printStudent1(struct student s)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;子函数中姓名：&quot; &lt;&lt; s.name &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void printStudent2(struct student *p)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;name is &quot; &lt;&lt; p-&gt;name &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">struct student s;</span><br><span class="line">s.name = 20;</span><br><span class="line">s.score = 85;</span><br><span class="line">printStudent(s);</span><br><span class="line">printStudent(&amp;s);</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-7结构体中const使用场景"><a href="#8-7结构体中const使用场景" class="headerlink" title="8.7结构体中const使用场景"></a>8.7结构体中const使用场景</h3><p>作用：用const来防止误操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//const的使用条件</span><br><span class="line">struct Student</span><br><span class="line">&#123;</span><br><span class="line">//成员列表</span><br><span class="line">string name;//姓名</span><br><span class="line">int age;//年龄</span><br><span class="line">int score;//分数</span><br><span class="line">&#125;;</span><br><span class="line">//将函数中的形参改为指针，可以减少内存空间，而且不会复制新的副本出来</span><br><span class="line">void printStudents(const student s)//加const防止误操作</span><br><span class="line">&#123;</span><br><span class="line">//加入const之后，一旦有了修改操作就会报错。</span><br><span class="line">cout &lt;&lt; &quot;name is &quot; &lt;&lt; s-&gt;name &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">struct Student s2 = &#123;&quot;李四&quot;,19,100&#125;;</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-8结构体案例"><a href="#8-8结构体案例" class="headerlink" title="8.8结构体案例"></a>8.8结构体案例</h3><h4 id="8-8-1案例1"><a href="#8-8-1案例1" class="headerlink" title="8.8.1案例1"></a>8.8.1案例1</h4><p>案例描述：</p><p>学校正在做毕设项目，每名老师带领5个学生，总共有3名老师，需求如下</p><p>设计学生和老师的结构体，其中在老师的结构体中，有老师姓名和一个存放5名学生的数组作为成员</p><p>学生的成员有姓名、考试分数、创建数组存放3名老师，通过函数给每个老师及所带的学生赋值</p><p>最终打印出老师数据以及老师所带的学生数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">struct Student</span><br><span class="line">&#123;</span><br><span class="line">//成员列表</span><br><span class="line">string sName;//姓名</span><br><span class="line">int age;//年龄</span><br><span class="line">int score;//分数</span><br><span class="line">&#125;;</span><br><span class="line">//老师的结构体</span><br><span class="line">struct teacher </span><br><span class="line">&#123;</span><br><span class="line"> string tName;</span><br><span class="line"> struct Student sArray[5];</span><br><span class="line">&#125;;</span><br><span class="line">void allocateSpace(struct teacher tArray[],int len)</span><br><span class="line">&#123;</span><br><span class="line">string nameSeed = &quot;ABCDE&quot;;</span><br><span class="line">//给老师赋值</span><br><span class="line">for (int i=0;i&lt;len;i++)</span><br><span class="line">&#123;</span><br><span class="line">tArray[i].tName = &quot;teacher_&quot;;</span><br><span class="line">tArray[i].tName += nameSeed[i];</span><br><span class="line">for (int j=0;j&lt;5;j++)</span><br><span class="line">&#123;</span><br><span class="line">tArray[i].sArray[j].sName = &quot;Student_&quot;;</span><br><span class="line">tArray[i].sArray[j].sName += nameSeed[i];</span><br><span class="line">int random = rand() % 61 + 40;//40~100</span><br><span class="line">tArray[i].sArray[j].score = random; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">void printInfo(struct teacher tArray[],int len)</span><br><span class="line">&#123;</span><br><span class="line">for (int i=0;i&lt;len;i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;Teacher&#x27;s name is &quot; &lt;&lt; tArray[i].tName &lt;&lt; endl;</span><br><span class="line">for (int j=0;j&lt;5;j++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;Student&#x27;s name is &quot; &lt;&lt; tArray[i].sArray[j].sName &lt;&lt;</span><br><span class="line">&quot;Student&#x27;s score is &quot; &lt;&lt; tArray[i].sArray[j].score &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">//随机数种子</span><br><span class="line">srand((unsigned int))time(NULL);//使得真正随机起来</span><br><span class="line">//创建3名老师的数组</span><br><span class="line">struct teacher tArray[3];</span><br><span class="line">//通过函数给3名老师的信息赋值，并给老师带的学生信息赋值</span><br><span class="line">int len = sizeof(tArray) / sizeof(tArray[0]);</span><br><span class="line">allocateSpace(tArray,len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-8-2-案例2"><a href="#8-8-2-案例2" class="headerlink" title="8.8.2 案例2"></a>8.8.2 案例2</h4><p>案例描述：</p><p>设计一个英雄的结构体，包括成员姓名、年龄、性别；创建结构体数组，数组中存放5名英雄。</p><p>通过冒泡排序的算法，将数组中的英雄按照年龄进行升序排序，最终打印排序后的结果。</p><p>五名英雄的信息如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;刘备&quot;,23,&quot;男&quot;&#125;,</span><br><span class="line">&#123;&quot;关羽&quot;,22,&quot;男&quot;&#125;,</span><br><span class="line">&#123;&quot;张飞&quot;,20,&quot;男&quot;&#125;,</span><br><span class="line">&#123;&quot;赵云&quot;,21,&quot;男&quot;&#125;,</span><br><span class="line">&#123;&quot;貂蝉&quot;,19,&quot;女&quot;&#125;,</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct Hero</span><br><span class="line">&#123;</span><br><span class="line">string name;</span><br><span class="line">int age;</span><br><span class="line">string sex;</span><br><span class="line">&#125;</span><br><span class="line">void bubbleSort(struct Hero heroArray[] , int len)</span><br><span class="line">&#123;</span><br><span class="line">for (int i=0;i&lt;len-1;i++)</span><br><span class="line">&#123;</span><br><span class="line">for (int j=0;j&lt;len-1-i;j++)</span><br><span class="line">&#123;</span><br><span class="line">if (heroArray[j]&lt;heroArray[j+1])</span><br><span class="line">&#123;</span><br><span class="line">struct Hero temp = heroArray[j];</span><br><span class="line">heroArray[j] = heroArray[j+1];</span><br><span class="line">heroArray[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">struct Hero heroArray[5] = &#123;</span><br><span class="line">&#123;&quot;刘备&quot;,23,&quot;男&quot;&#125;,</span><br><span class="line">&#123;&quot;关羽&quot;,22,&quot;男&quot;&#125;,</span><br><span class="line">&#123;&quot;张飞&quot;,20,&quot;男&quot;&#125;,</span><br><span class="line">&#123;&quot;赵云&quot;,21,&quot;男&quot;&#125;,</span><br><span class="line">&#123;&quot;貂蝉&quot;,19,&quot;女&quot;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">int len = sizeof(heroArray) / sizeof(heroArray[0]);</span><br><span class="line">for (int i=0;i&lt;len;i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;name is &quot; &lt;&lt; heroArray[i].name &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">bubbleSort(heroArray,len);</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-—通讯录管理系统"><a href="#C-—通讯录管理系统" class="headerlink" title="C++—通讯录管理系统"></a>C++—通讯录管理系统</h2><h3 id="1-系统需求"><a href="#1-系统需求" class="headerlink" title="1.系统需求"></a>1.系统需求</h3><p>通讯录是一个可以记录亲人，好友信息的工具。</p><p>本次主要通过C++来实现一个通讯录管理系统</p><p>系统中需要实现的功能如下：</p><ul><li>添加联系人：向通讯录中添加新人，信息包括（姓名、性别、年龄、联系电话、家庭住址）最多记录1000人</li><li>显示联系人：显示通讯录中所有联系人信息</li><li>删除联系人：按照姓名进行删除指定联系人</li><li>查找联系人：按照姓名查看指定联系人信息</li><li>修改联系人：按照姓名重新修改指定联系人</li><li>清空联系人：清空通讯录中所有信息</li><li>退出通讯录：退出当前使用的通讯录</li></ul><h3 id="2-创建项目"><a href="#2-创建项目" class="headerlink" title="2.创建项目"></a>2.创建项目</h3><p>创建新项目</p><p>添加文件</p><h3 id="3-菜单功能"><a href="#3-菜单功能" class="headerlink" title="3.菜单功能"></a>3.菜单功能</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//菜单界面</span><br><span class="line">void showMenu()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;***********************&quot; &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;*** 1.add person    ***&quot; &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;*** 2.show person   ***&quot; &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;*** 3.delete person ***&quot; &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;*** 4.search person ***&quot; &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;*** 5.modify person ***&quot; &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;*** 6.clear person  ***&quot; &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;*** 0.exit          ***&quot; &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;***********************&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-退出功能"><a href="#4-退出功能" class="headerlink" title="4.退出功能"></a>4.退出功能</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">while (true)</span><br><span class="line">&#123;</span><br><span class="line">//菜单调用</span><br><span class="line">showMenu();</span><br><span class="line">cin &gt;&gt; select;</span><br><span class="line">switch (select)</span><br><span class="line">&#123;</span><br><span class="line">case 1://add person</span><br><span class="line">break;</span><br><span class="line">case 2://show person</span><br><span class="line">break;</span><br><span class="line">case 3://delete person</span><br><span class="line">break;</span><br><span class="line">case 4://search person</span><br><span class="line">break;</span><br><span class="line">case 5://modify person</span><br><span class="line">break;</span><br><span class="line">case 0://exit</span><br><span class="line">cout &lt;&lt; &quot;Welcome to use it next time!&quot; &lt;&lt; endl;</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">break;</span><br><span class="line">default:</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-添加联系人"><a href="#5-添加联系人" class="headerlink" title="5.添加联系人"></a>5.添加联系人</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#define MAX 1000</span><br><span class="line">//菜单界面</span><br><span class="line"></span><br><span class="line">struct Person</span><br><span class="line">&#123;</span><br><span class="line">string name;</span><br><span class="line">//性别 1 男 2 女</span><br><span class="line">int m_Sex;</span><br><span class="line">int m_Age;</span><br><span class="line">string m_Phone;</span><br><span class="line">string m_Addr;</span><br><span class="line">&#125;;</span><br><span class="line">struct Addressbooks</span><br><span class="line">&#123;</span><br><span class="line">struct Person personArray[MAX];</span><br><span class="line">int m_Size;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">void addPerson(Addressbooks* abs)</span><br><span class="line">&#123;</span><br><span class="line">if (abs-&gt;m_Size == MAX)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;通讯录已满&quot; &lt;&lt; endl;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">string name;</span><br><span class="line">cout &lt;&lt; &quot;please input name: &quot; &lt;&lt; endl;</span><br><span class="line">cin &gt;&gt; name;</span><br><span class="line">abs-&gt;personArray[abs-&gt;m_Size].name = name;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;please input sex: &quot; &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;1--man&quot; &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;2--woman&quot; &lt;&lt; endl;</span><br><span class="line">int sex = 0;</span><br><span class="line">cin &gt;&gt; sex;</span><br><span class="line">while (true)</span><br><span class="line">&#123;</span><br><span class="line">if (sex == 1 || sex == 2)</span><br><span class="line">&#123;</span><br><span class="line">abs-&gt;personArray[abs-&gt;m_Size].m_Sex = sex;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; &quot;error,please input right data!&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;please input age: &quot; &lt;&lt; endl;</span><br><span class="line">int age = 0;</span><br><span class="line">cin &gt;&gt; age;</span><br><span class="line">abs-&gt;personArray[abs-&gt;m_Size].m_Age = age;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;please input phone :&quot; &lt;&lt; endl;</span><br><span class="line">string phone;</span><br><span class="line">cin &gt;&gt; phone;</span><br><span class="line">abs-&gt;personArray[abs-&gt;m_Size].m_Phone = phone;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;please input address :&quot; &lt;&lt; endl;</span><br><span class="line">string addr;</span><br><span class="line">cin &gt;&gt; addr;</span><br><span class="line">abs-&gt;personArray[abs-&gt;m_Size].m_Addr = addr;</span><br><span class="line"></span><br><span class="line">//upgrade size</span><br><span class="line">abs-&gt;m_Size++;</span><br><span class="line">cout &lt;&lt; &quot;add successfully&quot; &lt;&lt; endl;</span><br><span class="line">system(&quot;pause&quot;);//请按任意键继续</span><br><span class="line">system(&quot;cls&quot;);//清屏效果</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-显示联系人"><a href="#6-显示联系人" class="headerlink" title="6.显示联系人"></a>6.显示联系人</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">void showPerson(Addressbooks abs)</span><br><span class="line">&#123;</span><br><span class="line">if (abs.m_Size == 0)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;this is null&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">for (int i = 0; i &lt; abs.m_Size; i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;name is &quot; &lt;&lt; abs.personArray[i].name &lt;&lt; &quot;\t&quot;;</span><br><span class="line">cout &lt;&lt; &quot;sex is &quot; &lt;&lt; (abs.personArray[i].m_Sex == 1 ? &quot;man&quot;:&quot;woman&quot;) &lt;&lt; &quot;\t&quot;;</span><br><span class="line">cout &lt;&lt; &quot;age is &quot; &lt;&lt; abs.personArray[i].m_Age &lt;&lt; &quot;\t&quot;;</span><br><span class="line">cout &lt;&lt; &quot;phone is &quot; &lt;&lt; abs.personArray[i].m_Phone &lt;&lt; &quot;\t&quot;;</span><br><span class="line">cout &lt;&lt; &quot;address is &quot; &lt;&lt; abs.personArray[i].m_Addr &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">system(&quot;cls&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7删除联系人"><a href="#7删除联系人" class="headerlink" title="7删除联系人"></a>7删除联系人</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">int isExist(Addressbooks *abs, string name)</span><br><span class="line">&#123;</span><br><span class="line">for (int i = 0; i &lt; abs-&gt;m_Size; i++)</span><br><span class="line">&#123;</span><br><span class="line">if (abs-&gt;personArray[i].name == name)</span><br><span class="line">&#123;</span><br><span class="line">return i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void deletePerson(Addressbooks* abs)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;please input person if you need to delete&quot; &lt;&lt; endl;</span><br><span class="line">string name;</span><br><span class="line">cin &gt;&gt; name;</span><br><span class="line">int ret = isExist(abs, name);</span><br><span class="line">if (ret != -1)</span><br><span class="line">&#123;</span><br><span class="line">for (int i = ret; i &lt; abs-&gt;m_Size; i++)</span><br><span class="line">&#123;</span><br><span class="line">abs-&gt;personArray[i] = abs-&gt;personArray[i + 1];</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; &quot;delete successfully&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;without this person&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-查找联系人"><a href="#8-查找联系人" class="headerlink" title="8.查找联系人"></a>8.查找联系人</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">void findPerson(Addressbooks *abs)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;please input name if you need to search it&quot; &lt;&lt; endl;</span><br><span class="line">string name;</span><br><span class="line">cin &gt;&gt; name;</span><br><span class="line">int ret = isExist(abs, name);</span><br><span class="line">if (ret != -1)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;name is &quot; &lt;&lt; abs-&gt;personArray[ret].name &lt;&lt; &quot;\t&quot;;</span><br><span class="line">cout &lt;&lt; &quot;sex is &quot; &lt;&lt; (abs-&gt;personArray[ret].m_Sex == 1 ? &quot;man&quot; : &quot;woman&quot;) &lt;&lt; &quot;\t&quot;;</span><br><span class="line">cout &lt;&lt; &quot;age is &quot; &lt;&lt; abs-&gt;personArray[ret].m_Age &lt;&lt; &quot;\t&quot;;</span><br><span class="line">cout &lt;&lt; &quot;phone is &quot; &lt;&lt; abs-&gt;personArray[ret].m_Phone &lt;&lt; &quot;\t&quot;;</span><br><span class="line">cout &lt;&lt; &quot;address is &quot; &lt;&lt; abs-&gt;personArray[ret].m_Addr &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;without this person&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">system(&quot;cls&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-修改联系人"><a href="#9-修改联系人" class="headerlink" title="9.修改联系人"></a>9.修改联系人</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">void modifyPerson(Addressbooks *abs)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;please input name if you need to modify it&quot; &lt;&lt; endl;</span><br><span class="line">string name;</span><br><span class="line">cin &gt;&gt; name;</span><br><span class="line">int ret = isExist(abs, name);</span><br><span class="line">if (ret != -1)</span><br><span class="line">&#123;</span><br><span class="line">string name;</span><br><span class="line">cout &lt;&lt; &quot;please input name: &quot; &lt;&lt; endl;</span><br><span class="line">cin &gt;&gt; name;</span><br><span class="line">abs-&gt;personArray[ret].name = name;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;please input sex: &quot; &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;1--man&quot; &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;2--woman&quot; &lt;&lt; endl;</span><br><span class="line">int sex = 0;</span><br><span class="line">cin &gt;&gt; sex;</span><br><span class="line">while (true)</span><br><span class="line">&#123;</span><br><span class="line">if (sex == 1 || sex == 2)</span><br><span class="line">&#123;</span><br><span class="line">abs-&gt;personArray[ret].m_Sex = sex;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; &quot;error,please input right data!&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;please input age: &quot; &lt;&lt; endl;</span><br><span class="line">int age = 0;</span><br><span class="line">cin &gt;&gt; age;</span><br><span class="line">abs-&gt;personArray[ret].m_Age = age;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;please input phone :&quot; &lt;&lt; endl;</span><br><span class="line">string phone;</span><br><span class="line">cin &gt;&gt; phone;</span><br><span class="line">abs-&gt;personArray[ret].m_Phone = phone;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;please input address :&quot; &lt;&lt; endl;</span><br><span class="line">string addr;</span><br><span class="line">cin &gt;&gt; addr;</span><br><span class="line">abs-&gt;personArray[ret].m_Addr = addr;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;modify successfully&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;without this person&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">system(&quot;pause&quot;);//请按任意键继续</span><br><span class="line">system(&quot;cls&quot;);//清屏效果</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-清空联系人"><a href="#10-清空联系人" class="headerlink" title="10.清空联系人"></a>10.清空联系人</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void cleanPerson(Addressbooks* abs)</span><br><span class="line">&#123;</span><br><span class="line">abs-&gt;m_Size = 0;</span><br><span class="line">cout &lt;&lt; &quot;clear successfully&quot; &lt;&lt; endl;</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">system(&quot;cls&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-整体程序如下"><a href="#11-整体程序如下" class="headerlink" title="11.整体程序如下"></a>11.整体程序如下</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define MAX 1000</span><br><span class="line"></span><br><span class="line">struct Person</span><br><span class="line">&#123;</span><br><span class="line">string name;</span><br><span class="line">//性别 1 男 2 女</span><br><span class="line">int m_Sex;</span><br><span class="line">int m_Age;</span><br><span class="line">string m_Phone;</span><br><span class="line">string m_Addr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct Addressbooks</span><br><span class="line">&#123;</span><br><span class="line">struct Person personArray[MAX];</span><br><span class="line">int m_Size = 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void addPerson(Addressbooks* abs)</span><br><span class="line">&#123;</span><br><span class="line">if (abs-&gt;m_Size == MAX)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;通讯录已满&quot; &lt;&lt; endl;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">string name;</span><br><span class="line">cout &lt;&lt; &quot;please input name: &quot; &lt;&lt; endl;</span><br><span class="line">cin &gt;&gt; name;</span><br><span class="line">abs-&gt;personArray[abs-&gt;m_Size].name = name;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;please input sex: &quot; &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;1--man&quot; &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;2--woman&quot; &lt;&lt; endl;</span><br><span class="line">int sex = 0;</span><br><span class="line">cin &gt;&gt; sex;</span><br><span class="line">while (true)</span><br><span class="line">&#123;</span><br><span class="line">if (sex == 1 || sex == 2)</span><br><span class="line">&#123;</span><br><span class="line">abs-&gt;personArray[abs-&gt;m_Size].m_Sex = sex;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; &quot;error,please input right data!&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;please input age: &quot; &lt;&lt; endl;</span><br><span class="line">int age = 0;</span><br><span class="line">cin &gt;&gt; age;</span><br><span class="line">abs-&gt;personArray[abs-&gt;m_Size].m_Age = age;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;please input phone :&quot; &lt;&lt; endl;</span><br><span class="line">string phone;</span><br><span class="line">cin &gt;&gt; phone;</span><br><span class="line">abs-&gt;personArray[abs-&gt;m_Size].m_Phone = phone;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;please input address :&quot; &lt;&lt; endl;</span><br><span class="line">string addr;</span><br><span class="line">cin &gt;&gt; addr;</span><br><span class="line">abs-&gt;personArray[abs-&gt;m_Size].m_Addr = addr;</span><br><span class="line"></span><br><span class="line">//upgrade size</span><br><span class="line">abs-&gt;m_Size++;</span><br><span class="line">cout &lt;&lt; &quot;add successfully&quot; &lt;&lt; endl;</span><br><span class="line">system(&quot;pause&quot;);//请按任意键继续</span><br><span class="line">system(&quot;cls&quot;);//清屏效果</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void showPerson(Addressbooks abs)</span><br><span class="line">&#123;</span><br><span class="line">if (abs.m_Size == 0)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;this is null&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">for (int i = 0; i &lt; abs.m_Size; i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;name is &quot; &lt;&lt; abs.personArray[i].name &lt;&lt; &quot;\t&quot;;</span><br><span class="line">cout &lt;&lt; &quot;sex is &quot; &lt;&lt; (abs.personArray[i].m_Sex == 1 ? &quot;man&quot;:&quot;woman&quot;) &lt;&lt; &quot;\t&quot;;</span><br><span class="line">cout &lt;&lt; &quot;age is &quot; &lt;&lt; abs.personArray[i].m_Age &lt;&lt; &quot;\t&quot;;</span><br><span class="line">cout &lt;&lt; &quot;phone is &quot; &lt;&lt; abs.personArray[i].m_Phone &lt;&lt; &quot;\t&quot;;</span><br><span class="line">cout &lt;&lt; &quot;address is &quot; &lt;&lt; abs.personArray[i].m_Addr &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">system(&quot;cls&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int isExist(Addressbooks *abs, string name)</span><br><span class="line">&#123;</span><br><span class="line">for (int i = 0; i &lt; abs-&gt;m_Size; i++)</span><br><span class="line">&#123;</span><br><span class="line">if (abs-&gt;personArray[i].name == name)</span><br><span class="line">&#123;</span><br><span class="line">return i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void deletePerson(Addressbooks* abs)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;please input person if you need to delete&quot; &lt;&lt; endl;</span><br><span class="line">string name;</span><br><span class="line">cin &gt;&gt; name;</span><br><span class="line">int ret = isExist(abs, name);</span><br><span class="line">if (ret != -1)</span><br><span class="line">&#123;</span><br><span class="line">for (int i = ret; i &lt; abs-&gt;m_Size; i++)</span><br><span class="line">&#123;</span><br><span class="line">abs-&gt;personArray[i] = abs-&gt;personArray[i + 1];</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; &quot;delete successfully&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;without this person&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">system(&quot;cls&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void findPerson(Addressbooks *abs)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;please input name if you need to search it&quot; &lt;&lt; endl;</span><br><span class="line">string name;</span><br><span class="line">cin &gt;&gt; name;</span><br><span class="line">int ret = isExist(abs, name);</span><br><span class="line">if (ret != -1)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;name is &quot; &lt;&lt; abs-&gt;personArray[ret].name &lt;&lt; &quot;\t&quot;;</span><br><span class="line">cout &lt;&lt; &quot;sex is &quot; &lt;&lt; (abs-&gt;personArray[ret].m_Sex == 1 ? &quot;man&quot; : &quot;woman&quot;) &lt;&lt; &quot;\t&quot;;</span><br><span class="line">cout &lt;&lt; &quot;age is &quot; &lt;&lt; abs-&gt;personArray[ret].m_Age &lt;&lt; &quot;\t&quot;;</span><br><span class="line">cout &lt;&lt; &quot;phone is &quot; &lt;&lt; abs-&gt;personArray[ret].m_Phone &lt;&lt; &quot;\t&quot;;</span><br><span class="line">cout &lt;&lt; &quot;address is &quot; &lt;&lt; abs-&gt;personArray[ret].m_Addr &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;without this person&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">system(&quot;cls&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void modifyPerson(Addressbooks *abs)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;please input name if you need to modify it&quot; &lt;&lt; endl;</span><br><span class="line">string name;</span><br><span class="line">cin &gt;&gt; name;</span><br><span class="line">int ret = isExist(abs, name);</span><br><span class="line">if (ret != -1)</span><br><span class="line">&#123;</span><br><span class="line">string name;</span><br><span class="line">cout &lt;&lt; &quot;please input name: &quot; &lt;&lt; endl;</span><br><span class="line">cin &gt;&gt; name;</span><br><span class="line">abs-&gt;personArray[ret].name = name;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;please input sex: &quot; &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;1--man&quot; &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;2--woman&quot; &lt;&lt; endl;</span><br><span class="line">int sex = 0;</span><br><span class="line">cin &gt;&gt; sex;</span><br><span class="line">while (true)</span><br><span class="line">&#123;</span><br><span class="line">if (sex == 1 || sex == 2)</span><br><span class="line">&#123;</span><br><span class="line">abs-&gt;personArray[ret].m_Sex = sex;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; &quot;error,please input right data!&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;please input age: &quot; &lt;&lt; endl;</span><br><span class="line">int age = 0;</span><br><span class="line">cin &gt;&gt; age;</span><br><span class="line">abs-&gt;personArray[ret].m_Age = age;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;please input phone :&quot; &lt;&lt; endl;</span><br><span class="line">string phone;</span><br><span class="line">cin &gt;&gt; phone;</span><br><span class="line">abs-&gt;personArray[ret].m_Phone = phone;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;please input address :&quot; &lt;&lt; endl;</span><br><span class="line">string addr;</span><br><span class="line">cin &gt;&gt; addr;</span><br><span class="line">abs-&gt;personArray[ret].m_Addr = addr;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;modify successfully&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;without this person&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">system(&quot;pause&quot;);//请按任意键继续</span><br><span class="line">system(&quot;cls&quot;);//清屏效果</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void cleanPerson(Addressbooks* abs)</span><br><span class="line">&#123;</span><br><span class="line">abs-&gt;m_Size = 0;</span><br><span class="line">cout &lt;&lt; &quot;clear successfully&quot; &lt;&lt; endl;</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">system(&quot;cls&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//菜单界面</span><br><span class="line">void showMenu()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;***********************&quot; &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;*** 1.add person    ***&quot; &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;*** 2.show person   ***&quot; &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;*** 3.delete person ***&quot; &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;*** 4.search person ***&quot; &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;*** 5.modify person ***&quot; &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;*** 6.clear person  ***&quot; &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;*** 0.exit          ***&quot; &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;***********************&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">//创建通讯录结构体变量</span><br><span class="line">Addressbooks abs;</span><br><span class="line">int select = 0;//创建用户选择输入的变量</span><br><span class="line">while (true)</span><br><span class="line">&#123;</span><br><span class="line">//菜单调用</span><br><span class="line">showMenu();</span><br><span class="line">cin &gt;&gt; select;</span><br><span class="line">switch (select)</span><br><span class="line">&#123;</span><br><span class="line">case 1://add person</span><br><span class="line">addPerson(&amp;abs); //利用地址传递，可以修改实参</span><br><span class="line">break;</span><br><span class="line">case 2://show person</span><br><span class="line">showPerson(abs);</span><br><span class="line">break;</span><br><span class="line">case 3://delete person</span><br><span class="line">deletePerson(&amp;abs);</span><br><span class="line">break;</span><br><span class="line">case 4://search person</span><br><span class="line">findPerson(&amp;abs);</span><br><span class="line">break;</span><br><span class="line">case 5://modify person</span><br><span class="line">modifyPerson(&amp;abs);</span><br><span class="line">break;</span><br><span class="line">case 0://exit</span><br><span class="line">cleanPerson(&amp;abs);</span><br><span class="line">cout &lt;&lt; &quot;Welcome to use it next time!&quot; &lt;&lt; endl;</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">break;</span><br><span class="line">default:</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://luckytoadventure.com/categories/C/">C++</category>
      
      
      <category domain="https://luckytoadventure.com/tags/C/">C++</category>
      
      
      <comments>https://luckytoadventure.com/2023/12/24/C++%E5%85%A5%E9%97%A8/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
